<!--
  Side-by-side browser vs canvas_ity WASM test comparison
  Generated from upstream_test.html and test/test.c
-->

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>canvas_ity: Browser vs WASM Comparison</title>
  <style type="text/css">
    <!--
    @font-face { font-family: FontA; src: url(data:font/truetype;base64,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); }
    @font-face { font-family: FontB; src: url(data:font/truetype;base64,AAEAAAALAIAAAwAwT1MvMmirdVEAAAE4AAAAYGNtYXAHhQC5AAAB3AAAAIJjdnQgAEQFEQAAAmAAAAAEZ2x5ZjCUlAIAAAK0AAAGhmhlYWQe1LMzAAAAvAAAADZoaGVhDf8FBAAAAPQAAAAkaG10eDmaBAMAAAGYAAAARGxvY2EAAEj6AAACZAAAAFBtYXhwAHUAtwAAARgAAAAgbmFtZVZpOPsAAAk8AAAA23Bvc3T/aQBmAAAKGAAAACAAAAEAAAEAAIakcHRfDzz1AB0IAAAAAADcB1gvAAAAANwUDqb/+f5tB5AH8wAAAAgAAgABAAAAAAABAAAFu/+6ALgIAP/5/ToHkAABAAAAAAAAAAAAAAAAAAAADwABAAAAEwBAABAAcAAIAAIAAAABAAEAAABAAAMACAABAAQD/wGQAAUAAAUzBZkAAAEeBTMFmQAAA9cAZgISAAACAAUDAAAAAAAAAAAAQwIAAAAEAAAAAAAAAFBmRWQAgAAgAwEGQP5AALgFuwBGAAAAAQAAAAADmwW3AAAAIAABAuwARAQAAAAFogAiBikAVwK0ABQDqAA8BGwANALYAE8CsQA8A8j/+QPI//kCtAAUAAABBQgAAAADhABkAGQAZABkAGQAAAABAAMAAQAAAAwABAB2AAAAFgAQAAMABgAgACoASQBhAG4AdAB2AHkAzQMB//8AAAAgACoAQwBhAG4AcwB2AHkAzQMB////4f/YAAD/pP+Y/5T/k/+R/z79CwABAAAAAAASAAAAAAAAAAAAAAAAAAAAAAADABIADgAPABAAEQAEAAAARAURAAAAAAAAACwAAAAsAAAAqAAAASYAAAGkAAACPgAAAtoAAANaAAAD1AAABEAAAATCAAAE3gAABRoAAAYiAAAGOgAABkoAAAZaAAAGagAABoYAAgBEAAACZAVVAAMABwADsQEAMxEhESUhESFEAiD+JAGY/mgFVfqrRATNAP//ACIAWAWBBacQpwAMBaIEUNLALT7SwNLAEKcADAF+BdjSwNLALT7SwBCnAAwAAgGsLT7SwC0+LT4QpwAMBCQAKC0+LT7SwC0+EKcADP/qBA0AAMAAQAAAABCnAAwFvgHuAABAAMAAAAAQLwAMA94F7MAAEAcADAHCAAwAAQBX/+IFuwW7ACMAABMQNzYhMgUWFRQHBicCISADBhUUFxYhIBM2FxYHBgcEISABJle41gGOpQE1DxISBqD+5P7fuo2WpgFpATOdCRgXAhgb/vf+zP61/uqRAsQBKNb5kAfdCQMCCwE7/vvFxPbb8gE6EgUEEs0RnwERjgAAAQAU//oCfAW0ACMAADMiJyY3NjcSNzYDJicmNzYzJCUWFxYHBgcCFxYTFhcWFxYHBjcXAQEXnwQNAQEVCaAVAQEVASIBCBsBARu2BAwCAgwDuB0CAR//DAoIPmkBT76mAVyVFwMVEgQGARcNBzWF/ru8tf6odR8FGQ0BBgAAAgA8/+8DeQORAAgALgAANxY3NicmBw4CPgMnJicmBwYXFgcGJyY3NjMyAwIXFjc2NzYHBgcGJwYnJifiA4yWAwEyS6akRZCJhwICQChOcwQFciIQCR2yzeoXFAQFTUAOKgwqmWVSkGy2BMOFDQ/aYA8TVDtmKCwujX44IgQGQTgjCi4cHKv+yf70YI8XEwMKIn0FA3V1AQKuAAEANP//BE4DtgAzAAAzIjU0MzIDJjc2JzYzMgcGByQ3NhMSFxY3MhUUIzAhIjU0NzYnMAMmBwYHMAMCNzYXFicgUBwwZA0GAQFLnkA6EhUCAQaL1AcJAwJnEhX+piUhRwIFAdl6WwkOai0DAw7+0h4VAZW8YEwhZS83NXQEB/7q/qKPaAEaFiMYBxFEAdjKCQVD/nL+3AUCHCIBAAEET//uBokDmwAlAAAlJjc2MzIXFjc2NzYnJjc2NzYXFgcGJyYnJgcGBwYXFhcWBwYlJgRVBggDFRQMVmyXCwas4Bor921kDwYBFxQOZTxhKRyZSkxUBQn+3NczOlQcHLoOE6NNaYeT+gQCOBKIFAQEGKACA5JkZjJDSYPlAQEAAQA8/+wChAQRACMAABMmJyY3Njc2FxYHBhcWNxYVFAcGJyYHAhcWFxY3BicmExI1NGgiBgQcXEIVCiADCFQ/lTIyjE5PAQgICaFVSTnN8xEUAy4FFxAWSkIVBAsgUAIBBwouNQMHAQFR/ruJpwEBJ5QEBQEBATSqUgAB//n/ugO0A4wAHgAAJSYBJicFMhUUBwYVFBM2EzYnJic0NzY3BgcABwYHIgG2F/7TEWgBZB4ePeFPdwc+LAEopIVfGP7hCQ0eJA6AAn0kXQIWEgsWQCb+Py8B2hkSDBoQAQIFPUb9f1R5AQAB//n+bQO0A4wAJgAAJTQBJicFMhUUBwYVFBM2EzYnJic0NzY3BgcCBwIHBiMmNTY3Njc2Aar+yBFoAWQeHj3hRYEHPiwBKKSFXxjiRp4BGDhYAVkgBlosSQKWJF0CFhILFkAm/j8oAeEaEQwaEAECBT1G/duw/nEDNQFQGRoJDcv//wAU//oC1wfzEGcADAARAtU/+EAAEgYABAAAAAEBBQMjAsYFHgANAAABNhM2NzYXFgcGBwYnJgEQMKgaDlpKEh7CkhQcHwNKawElLQMUGAUn/qIXBwcAABAAAP5wB5AGAAADAAcACwAPABMAFwAbAB8AIwAnACsALwAzADcAOwA/AAAQECAQABAgEQAQIRAAECEREhEgEAARIBEAESEQABEhERMQIBABECARARAhEAEQIRETESAQAREgEQERIRABESERAZD+cAGQ/nABkP5wAZBwAZD+cAGQ/nABkP5wAZBwAZD+cAGQ/nABkP5wAZBwAZD+cAGQ/nABkP5wAZD+cAGQ/nACAAGQ/nACAAGQ/nACAAGQ/nD6AAGQ/nACAAGQ/nACAAGQ/nACAAGQ/nD6AAGQ/nACAAGQ/nACAAGQ/nACAAGQ/nD6AAGQ/nACAAGQ/nACAAGQ/nACAAGQ/nAA//8AZAAyAyAFqhAnABIAAP6iAAQAEgAD//8AZAGQAyAETBAGABIAAP//AGQBkAMgBEwQBgASAAD//wBkAZADIARMEAYAEgAAAAEAZAGQAyAETAADAAASIBAgZAK8/UQETP1EAAAAAAAADACWAAEAAAAAAAEABQAAAAEAAAAAAAIABwAFAAEAAAAAAAMABQAAAAEAAAAAAAQABQAAAAEAAAAAAAUACwAMAAEAAAAAAAYABQAAAAMAAQQJAAEACgAXAAMAAQQJAAIADgAhAAMAAQQJAAMACgAXAAMAAQQJAAQACgAXAAMAAQQJAAUAFgAvAAMAAQQJAAYACgAXRm9udEJSZWd1bGFyVmVyc2lvbiAxLjAARgBvAG4AdABCAFIAZQBnAHUAbABhAHIAVgBlAHIAcwBpAG8AbgAgADEALgAwAAADAAAAAAAA/2YAZgAAAAAAAAAAAAAAAAAAAAAAAAAA); }
    @font-face { font-family: FontC; src: url(data:font/truetype;base64,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); }
    @font-face { font-family: FontD; src: url(data:font/truetype;base64,AAEAAAA=); }
    @font-face { font-family: FontE; src: url(data:font/truetype;base64,AAEAAAALAIAAAwAwT1MvMmisck8AAAE4AAAAYGNtYXAXewGCAAAB3AAAAUJjdnQgAEQFEQAAAyAAAAAEZ2x5ZjCUlAIAAANMAAAGhmhlYWQe1bIjAAAAvAAAADZoaGVhDf8FBAAAAPQAAAAkaG10eDmaBAMAAAGYAAAARGxvY2ERbxMOAAADJAAAAChtYXhwAHUAtwAAARgAAAAgbmFtZVZpNvsAAAnUAAAA23Bvc3T/aQBmAAAKsAAAAA==); }
    @font-face { font-family: FontF; src: url(data:font/truetype;base64,AAEAAAALAIAAAwAwT1MvMmisck8AAAE4AAAAYGNtYXAXewGCAAAB3AAAAUJjdnQgAEQFEQAAAyAAAAAEZ2x5ZjCUlAIAAANMAAAGhmhlYWQe1bIjAAAAvAAAADZoaGVhDf8FBAAAAPQAAAAkaG10eDmaBAMAAAGYAAAARGxvY2ERbxMOAAADJAAAAChtYXhwAHUAtwAAARgAAAAgbmFtZVZpNvsAAAnUAAAA23Bvc3T/aQBmAAAKsAAAACAAAQAAAAEAAEPW4v5fDzz1AB0IAAAAAADcB1gvAAAAANwUDpf/+f5tB5AH8wAAAAgAAgAAAAAAAA==); }
    @font-face { font-family: FontG; src: url(data:font/truetype;base64,AAEAAAABABAAAAAAaGVhZB7h+0cAAAAcAAAANgABAAAAAQAAC4VXZl8PPPUAHQgAAAAAANwHWC8AAAAA3CBXu//5/m0HkAfzAAAACAACAAAAAAAA); }
    body { background: #c4c4c4; font-family: sans-serif; color: #505050; }
    h1 { margin: 1rem; }
    h2 { font-size: medium; margin: 0.3rem 0; }
    .test-container { background: #e0e0e0; border: 2px solid #a8a8a8; border-radius: 8px; box-shadow: 0 4px 8px 0 rgba(0,0,0,0.4); display: inline-block; vertical-align: top; margin: 1rem; padding: 0.5rem; }
    .panels { display: flex; gap: 8px; }
    .panel { text-align: center; }
    .panel-label { font-size: x-small; font-weight: bold; color: #808080; margin-bottom: 2px; }
    canvas { border: 2px solid #a8a8a8; background: url(data:image/gif;base64,R0lGODdhEAAQAIACAMTExODg4CwAAAAAEAAQAAACH4xvoKuIzNyBSyYKbMDZcv15HAaSIlWiJ5Sya/RWVgEAOw==); background-attachment: fixed; display: block; }
    .placeholder { display: flex; align-items: center; justify-content: center; border: 2px dashed #a8a8a8; background: #f0f0f0; color: #999; font-size: small; font-style: italic; }
    #status { margin: 1rem; padding: 0.5rem; background: #ffe; border: 1px solid #cc0; font-family: monospace; font-size: small; white-space: pre-wrap; }
    -->
  </style>
</head>
<body>

<h1>canvas_ity: Browser vs WASM</h1>
<p style="margin:1rem">Left: browser Canvas 2D &mdash; Right: canvas_ity compiled to WASM via Emscripten.</p>
<div id="status">Loading WASM module...</div>

<div class="test-container">
<h2>scale_<wbr>uniform</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<canvas id="scale_uniform_browser" width="256" height="256"></canvas>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="scale_uniform_wasm" width="256" height="256"></canvas>
</div>
</div>
<script type="text/javascript">
    window.addEventListener( "load", function( event ) {
        const element = document.getElementById( "scale_uniform_browser" );
        const that = element.getContext( "2d" );
        const width = element.width;
        const height = element.height;
        that.strokeStyle = "#000000";
        that.setLineDash( [ 1.0 ] );
        that.lineCap = "round";
        for ( let size = 8.0; size < Math.min( width, height ); size *= 2.0 )
        {
            that.scale( 2.0, 2.0 );
            that.strokeRect( 0.0, 0.0, 8.0, 8.0 );
        }
    } );
</script>
</div>

<div class="test-container">
<h2>scale_<wbr>non_<wbr>uniform</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<canvas id="scale_non_uniform_browser" width="256" height="256"></canvas>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="scale_non_uniform_wasm" width="256" height="256"></canvas>
</div>
</div>
<script type="text/javascript">
    window.addEventListener( "load", function( event ) {
        const element = document.getElementById( "scale_non_uniform_browser" );
        const that = element.getContext( "2d" );
        const width = element.width;
        const height = element.height;
        that.strokeStyle = "#000000";
        that.setLineDash( [ 4.0 ] );
        that.scale( 4.0, 0.5 );
        that.strokeRect( width * 0.125 / 4.0, height * 0.125 / 0.5,
                         width * 0.75 / 4.0, height * 0.75 / 0.5 );
    } );
</script>
</div>

<div class="test-container">
<h2>rotate</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<canvas id="rotate_browser" width="256" height="256"></canvas>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="rotate_wasm" width="256" height="256"></canvas>
</div>
</div>
<script type="text/javascript">
    window.addEventListener( "load", function( event ) {
        const element = document.getElementById( "rotate_browser" );
        const that = element.getContext( "2d" );
        const width = element.width;
        const height = element.height;
        that.strokeStyle = "#000000";
        for ( let step = 0; step < 64; ++step )
        {
            that.rotate( 3.14159265 / 2.0 / 64.0 );
            that.strokeRect( 0.0, 0.0, width, height );
        }
    } );
</script>
</div>

<div class="test-container">
<h2>translate</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<canvas id="translate_browser" width="256" height="256"></canvas>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="translate_wasm" width="256" height="256"></canvas>
</div>
</div>
<script type="text/javascript">
    window.addEventListener( "load", function( event ) {
        const element = document.getElementById( "translate_browser" );
        const that = element.getContext( "2d" );
        const width = element.width;
        const height = element.height;
        that.strokeStyle = "#000000";
        for ( let step = 0.0; step < 32.0; step += 1.0 )
        {
            that.translate( ( 0.5 - step / 32.0 ) * width * 0.2,
                            height / 32.0 );
            that.beginPath();
            that.arc( 0.0, 0.0, width * 0.125, 0.0, 6.28318531 );
            that.closePath();
            that.stroke();
        }
    } );
</script>
</div>

<div class="test-container">
<h2>transform</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<canvas id="transform_browser" width="256" height="256"></canvas>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="transform_wasm" width="256" height="256"></canvas>
</div>
</div>
<script type="text/javascript">
    window.addEventListener( "load", function( event ) {
        const element = document.getElementById( "transform_browser" );
        const that = element.getContext( "2d" );
        const width = element.width;
        const height = element.height;
        that.strokeStyle = "#000000";
        for ( let step = 0; step < 8; ++step )
        {
            that.transform( 1.0, 0.0, 0.1, 1.0, width * -0.05, 0.0 );
            that.strokeRect( width * 0.25, height * 0.25,
                             width * 0.5, height * 0.5 );
        }
    } );
</script>
</div>

<div class="test-container">
<h2>transform_<wbr>fill</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<canvas id="transform_fill_browser" width="256" height="256"></canvas>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="transform_fill_wasm" width="256" height="256"></canvas>
</div>
</div>
<script type="text/javascript">
    window.addEventListener( "load", function( event ) {
        const element = document.getElementById( "transform_fill_browser" );
        const that = element.getContext( "2d" );
        const width = element.width;
        const height = element.height;
        const checker = new Uint8ClampedArray( 1024 );
        for ( let index = 0; index < 1024; ++index )
            checker[ index ] =
                ( ( index >> 5 & 1 ) ^ ( index >> 9 & 1 ) ^
                  ( ( index & 3 ) == 3 ) ) * 255;
        const image = document.createElement( "canvas" );
        image.width = 16;
        image.height = 16;
        image.getContext( "2d" ).putImageData(
            new ImageData( checker, 16, 16 ), 0, 0 );
        that.fillStyle = that.createPattern( image, "repeat" );
        that.beginPath();
        that.rect( width * 0.2, height * 0.2,
                   width * 0.6, height * 0.6 );
        that.transform( 1.0, 0.5, -0.5, 1.0, 0.0, 0.0 );
        that.fill();
    } );
</script>
</div>

<div class="test-container">
<h2>transform_<wbr>stroke</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<canvas id="transform_stroke_browser" width="256" height="256"></canvas>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="transform_stroke_wasm" width="256" height="256"></canvas>
</div>
</div>
<script type="text/javascript">
    window.addEventListener( "load", function( event ) {
        const element = document.getElementById( "transform_stroke_browser" );
        const that = element.getContext( "2d" );
        const width = element.width;
        const height = element.height;
        that.strokeStyle = "#000000";
        that.lineWidth = 8.0;
        that.setLineDash( [ 22.0, 8.0, 10.0, 8.0 ] );
        that.beginPath();
        that.arc( width * 0.5, height * 0.5, Math.min( width, height ) * 0.4,
                  0.0, 6.28318531 );
        that.closePath();
        that.transform( 1.0, 1.0, 0.0, 2.0, 0.0, 0.0 );
        that.stroke();
    } );
</script>
</div>

<div class="test-container">
<h2>set_<wbr>transform</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<canvas id="set_transform_browser" width="256" height="256"></canvas>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="set_transform_wasm" width="256" height="256"></canvas>
</div>
</div>
<script type="text/javascript">
    window.addEventListener( "load", function( event ) {
        const element = document.getElementById( "set_transform_browser" );
        const that = element.getContext( "2d" );
        const width = element.width;
        const height = element.height;
        that.strokeStyle = "#000000";
        for ( let step = 0; step < 8; ++step )
            that.setTransform( 1.0, 0.0, 0.1, 1.0, width * -0.05, 0.0 );
        that.strokeRect( width * 0.25, height * 0.25,
                         width * 0.5, height * 0.5 );
    } );
</script>
</div>

<div class="test-container">
<h2>global_<wbr>alpha</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<canvas id="global_alpha_browser" width="256" height="256"></canvas>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="global_alpha_wasm" width="256" height="256"></canvas>
</div>
</div>
<script type="text/javascript">
    window.addEventListener( "load", function( event ) {
        const element = document.getElementById( "global_alpha_browser" );
        const that = element.getContext( "2d" );
        const width = element.width;
        const height = element.height;
        that.strokeStyle = "#000000";
        that.lineWidth = 3.0;
        for ( let y = 0.0; y < 6.0; y += 1.0 )
            for ( let x = 0.0; x < 6.0; x += 1.0 )
            {
                that.fillStyle = "rgba(" + x / 5.0 * 255 + ",255," +
                    y / 5.0 * 255 + "," + x / 5.0 + ")";
                that.globalAlpha = y / 4.0 - 0.25;
                that.beginPath();
                that.rect( ( x + 0.1 ) / 6.0 * width, ( y + 0.1 ) / 6.0 * height,
                           0.8 / 6.0 * width, 0.8 / 6.0 * height );
                that.fill();
                that.stroke();
            }
    } );
</script>
</div>

<div class="test-container">
<h2>global_<wbr>composite_<wbr>operation</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<canvas id="global_composite_operation_browser" width="256" height="256"></canvas>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="global_composite_operation_wasm" width="256" height="256"></canvas>
</div>
</div>
<script type="text/javascript">
    window.addEventListener( "load", function( event ) {
        const element = document.getElementById( "global_composite_operation_browser" );
        const that = element.getContext( "2d" );
        const width = element.width;
        const height = element.height;
        const operations = [
            "source-in", "copy", "source-out", "destination-in",
            "destination-atop", "lighter", "destination-over",
            "destination-out", "source-atop", "source-over", "xor" ];
        const operationsValue = [ 1, 2, 3, 4, 7, 10, 11, 12, 13, 14, 15 ];
        const boxWidth = 0.25 * width;
        const boxHeight = 0.25 * height;
        for ( let index = 0; index < 11; ++index )
        {
            const column = operationsValue[ index ] % 4;
            const row = Math.trunc( operationsValue[ index ] / 4 );
            that.save();
            that.beginPath();
            that.rect( column * boxWidth, row * boxHeight,
                       boxWidth, boxHeight );
            that.clip();
            that.fillStyle = "#0000ff";
            that.fillRect( ( column + 0.4 ) * boxWidth,
                           ( row + 0.4 ) * boxHeight,
                           0.4 * boxWidth, 0.4 * boxHeight );
            that.globalCompositeOperation = operations[ index ];
            that.fillStyle = "#ff0000";
            that.fillRect( ( column + 0.2 ) * boxWidth,
                           ( row + 0.2 ) * boxHeight,
                           0.4 * boxWidth, 0.4 * boxHeight );
            that.restore();
        }
    } );
</script>
</div>

<div class="test-container">
<h2>shadow_<wbr>color</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<canvas id="shadow_color_browser" width="256" height="256"></canvas>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="shadow_color_wasm" width="256" height="256"></canvas>
</div>
</div>
<script type="text/javascript">
    window.addEventListener( "load", function( event ) {
        const element = document.getElementById( "shadow_color_browser" );
        const that = element.getContext( "2d" );
        const width = element.width;
        const height = element.height;
        that.shadowOffsetX = 5.0;
        that.shadowOffsetY = 5.0;
        for ( let row = 0.0; row < 5.0; row += 1.0 )
        {
            const y = ( row + 0.25 ) * 0.2 * height;
            that.fillStyle = "rgba(0,0,0," + 0.25 * row + ")";
            that.shadowColor = "rgba(255,-255,0,0.25)";
            that.fillRect( 0.05 * width, y,
                           0.15 * width, 0.1 * height );
            that.shadowColor = "rgba(0,255,0,0.5)";
            that.fillRect( 0.30 * width, y,
                           0.15 * width, 0.1 * height );
            that.shadowColor = "rgba(0,0,510,0.75)";
            that.fillRect( 0.55 * width, y,
                           0.15 * width, 0.1 * height );
            that.shadowColor = "rgba(255,255,255,100.0)";
            that.fillRect( 0.80 * width, y,
                           0.15 * width, 0.1 * height );
        }
    } );
</script>
</div>

<div class="test-container">
<h2>shadow_<wbr>offset</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<canvas id="shadow_offset_browser" width="256" height="256"></canvas>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="shadow_offset_wasm" width="256" height="256"></canvas>
</div>
</div>
<script type="text/javascript">
    window.addEventListener( "load", function( event ) {
        const element = document.getElementById( "shadow_offset_browser" );
        const that = element.getContext( "2d" );
        const width = element.width;
        const height = element.height;
        that.shadowBlur = 2.0;
        that.fillStyle = "#ffffff";
        that.shadowColor = "#000000";
        for ( let y = 0.0; y < 5.0; y += 1.0 )
            for ( let x = 0.0; x < 5.0; x += 1.0 )
            {
                that.shadowOffsetX = ( x - 2.0 ) * 4.0;
                that.shadowOffsetY = ( y - 2.0 ) * 4.0;
                that.fillRect( ( x + 0.25 ) * 0.2 * width,
                               ( y + 0.25 ) * 0.2 * height,
                               0.1 * width, 0.1 * height );
            }
    } );
</script>
</div>

<div class="test-container">
<h2>shadow_<wbr>offset_<wbr>offscreen</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<canvas id="shadow_offset_offscreen_browser" width="256" height="256"></canvas>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="shadow_offset_offscreen_wasm" width="256" height="256"></canvas>
</div>
</div>
<script type="text/javascript">
    window.addEventListener( "load", function( event ) {
        const element = document.getElementById( "shadow_offset_offscreen_browser" );
        const that = element.getContext( "2d" );
        const width = element.width;
        const height = element.height;
        that.shadowOffsetX = width;
        that.fillStyle = "#ff0000";
        that.shadowColor = "rgba(0,0,0,0.5)";
        that.fillRect( width * -0.6875, height * 0.0625,
                       width * 0.375, height * 0.375 );
        that.beginPath();
        that.arc( width * 0.5, height * 0.75, Math.min( width, height ) * 0.2,
                  0.0, 6.28318531 );
        that.closePath();
        that.fill();
    } );
</script>
</div>

<div class="test-container">
<h2>shadow_<wbr>blur</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<canvas id="shadow_blur_browser" width="256" height="256"></canvas>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="shadow_blur_wasm" width="256" height="256"></canvas>
</div>
</div>
<script type="text/javascript">
    window.addEventListener( "load", function( event ) {
        const element = document.getElementById( "shadow_blur_browser" );
        const that = element.getContext( "2d" );
        const width = element.width;
        const height = element.height;
        that.fillStyle = "#ffffff";
        that.shadowColor = "#000000";
        that.shadowOffsetX = 5.0;
        that.shadowOffsetY = 5.0;
        for ( let x = 0.0; x < 5.0; x += 1.0 )
            for ( let y = 4.0; y >= 0.0; y -= 1.0 )
            {
                that.shadowBlur = ( y * 5.0 + x ) * 0.5 - 0.5;
                that.fillRect( ( x + 0.25 ) * 0.2 * width,
                               ( y + 0.25 ) * 0.2 * height,
                               0.1 * width, 0.1 * height );
            }
    } );
</script>
</div>

<div class="test-container">
<h2>shadow_<wbr>blur_<wbr>offscreen</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<canvas id="shadow_blur_offscreen_browser" width="256" height="256"></canvas>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="shadow_blur_offscreen_wasm" width="256" height="256"></canvas>
</div>
</div>
<script type="text/javascript">
    window.addEventListener( "load", function( event ) {
        const element = document.getElementById( "shadow_blur_offscreen_browser" );
        const that = element.getContext( "2d" );
        const width = element.width;
        const height = element.height;
        that.fillStyle = "#ffffff";
        that.shadowColor = "#000000";
        that.shadowBlur = 5.0;
        that.fillRect( 0.0, height * 2.0, width, height );
        that.fillRect( 0.0, height * -2.0, width, height );
        that.fillRect( width + 1.0, 0, width, height );
        that.fillRect( -width - 1.0, 0, width, height );
    } );
</script>
</div>

<div class="test-container">
<h2>shadow_<wbr>blur_<wbr>composite</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<canvas id="shadow_blur_composite_browser" width="256" height="256"></canvas>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="shadow_blur_composite_wasm" width="256" height="256"></canvas>
</div>
</div>
<script type="text/javascript">
    window.addEventListener( "load", function( event ) {
        const element = document.getElementById( "shadow_blur_composite_browser" );
        const that = element.getContext( "2d" );
        const width = element.width;
        const height = element.height;
        const radius = Math.min( width, height ) * 0.5;
        that.arc( 0.5 * width, 0.5 * height, radius, 0.0, 6.28318531 );
        that.clip();
        that.fillStyle = "#0000ff";
        that.shadowColor = "#000000";
        that.fillRect( 0.4 * width, 0.0, 0.2 * width, height );
        that.globalCompositeOperation = "destination-atop";
        that.strokeStyle = "#ff0000";
        that.setLineDash( [ 16.0, 4.0 ] );
        that.lineWidth = 15.0;
        that.shadowOffsetX = 5.0;
        that.shadowOffsetY = 5.0;
        that.shadowBlur = 6.0;
        that.shadowColor = "#000000";
        that.beginPath();
        that.arc( 0.45 * width, 0.85 * height, radius * 0.5, 0.0, 6.28318531 );
        that.closePath();
        that.stroke();
        that.globalCompositeOperation = "source-over";
        that.beginPath();
        that.arc( 0.75 * width, 0.25 * height, radius, 0.0, 6.28318531 );
        that.closePath();
        that.stroke();
    } );
</script>
</div>

<div class="test-container">
<h2>line_<wbr>width</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<canvas id="line_width_browser" width="256" height="256"></canvas>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="line_width_wasm" width="256" height="256"></canvas>
</div>
</div>
<script type="text/javascript">
    window.addEventListener( "load", function( event ) {
        const element = document.getElementById( "line_width_browser" );
        const that = element.getContext( "2d" );
        const width = element.width;
        const height = element.height;
        that.strokeStyle = "#000000";
        that.lineWidth = 4.0;
        for ( let step = 0.0; step < 16.0; step += 1.0 )
        {
            const left = ( step + 0.25 ) / 16.0 * width;
            const right = ( step + 0.75 ) / 16.0 * width;
            that.beginPath();
            that.moveTo( left, 0.0 );
            that.bezierCurveTo( left, 0.5 * height,
                                right, 0.5 * height,
                                right, height );
            that.lineWidth = 0.5 * ( step - 1 );
            that.stroke();
        }
        that.fillStyle = "#ffffff";
        that.globalCompositeOperation = "source-atop";
        that.fillRect( 0.0, 0.5 * height, width, 0.5 * height );
        that.globalCompositeOperation = "destination-over";
        that.fillRect( 0.0, 0.25 * height, width, 0.25 * height );
        that.fillStyle = "#000000";
        that.fillRect( 0.0, 0.5 * height, width, 0.25 * height );
    } );
</script>
</div>

<div class="test-container">
<h2>line_<wbr>width_<wbr>angular</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<canvas id="line_width_angular_browser" width="256" height="256"></canvas>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="line_width_angular_wasm" width="256" height="256"></canvas>
</div>
</div>
<script type="text/javascript">
    window.addEventListener( "load", function( event ) {
        const element = document.getElementById( "line_width_angular_browser" );
        const that = element.getContext( "2d" );
        const width = element.width;
        const height = element.height;
        for ( let step = 0.0; step < 5.0; step += 1.0 )
        {
            const grey = ( step + 1.0 ) / 5.0;
            that.strokeStyle = "rgb(" + grey * 255.0 + "," + grey * 255.0 +
                "," + grey * 255.0 + ")";
            that.beginPath();
            that.moveTo( 0.1 * width, 0.1 * height );
            that.bezierCurveTo( 1.2 * width, 1.0 * height,
                                1.2 * width, -0.0 * height,
                                0.1 * width, 0.9 * height );
            that.lineWidth = 30.0 - 7.0 * step;
            that.stroke();
        }
    } );
</script>
</div>

<div class="test-container">
<h2>line_<wbr>cap</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<canvas id="line_cap_browser" width="256" height="256"></canvas>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="line_cap_wasm" width="256" height="256"></canvas>
</div>
</div>
<script type="text/javascript">
    window.addEventListener( "load", function( event ) {
        const element = document.getElementById( "line_cap_browser" );
        const that = element.getContext( "2d" );
        const width = element.width;
        const height = element.height;
        that.strokeStyle = "#000000";
        that.lineWidth = 24.0;
        const caps = [ "butt", "square", "round" ];
        for ( let index = 0; index < 3; ++index )
        {
            const right = ( index + 1 ) / 3.0 * width - 20.0;
            that.beginPath();
            that.moveTo( right, 0.125 * height );
            that.bezierCurveTo( right, 0.125 * height + 100.0,
                                right - 100.0, 0.875 * height,
                                right, 0.875 * height );
            that.lineCap = caps[ index ];
            that.stroke();
        }
    } );
</script>
</div>

<div class="test-container">
<h2>line_<wbr>cap_<wbr>offscreen</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<canvas id="line_cap_offscreen_browser" width="256" height="256"></canvas>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="line_cap_offscreen_wasm" width="256" height="256"></canvas>
</div>
</div>
<script type="text/javascript">
    window.addEventListener( "load", function( event ) {
        const element = document.getElementById( "line_cap_offscreen_browser" );
        const that = element.getContext( "2d" );
        const width = element.width;
        const height = element.height;
        that.strokeStyle = "#000000";
        that.lineWidth = 36.0;
        const caps = [ "butt", "square", "round" ];
        for ( let index = 0; index < 3; ++index )
        {
            const x = ( index + 0.5 ) / 3.0 * width;
            const y = ( index + 0.5 ) / 3.0 * height;
            that.beginPath();
            that.moveTo( x, -19.0 );
            that.lineTo( x, -9.0 );
            that.moveTo( x, height + 17.0 );
            that.lineTo( x, height + 27.0 );
            that.moveTo( -27.0, y );
            that.lineTo( -17.0, y );
            that.moveTo( width + 9.0, y );
            that.lineTo( width + 19.0, y );
            that.lineCap = caps[ index ];
            that.stroke();
        }
    } );
</script>
</div>

<div class="test-container">
<h2>line_<wbr>join</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<canvas id="line_join_browser" width="256" height="256"></canvas>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="line_join_wasm" width="256" height="256"></canvas>
</div>
</div>
<script type="text/javascript">
    window.addEventListener( "load", function( event ) {
        const element = document.getElementById( "line_join_browser" );
        const that = element.getContext( "2d" );
        const width = element.width;
        const height = element.height;
        that.strokeStyle = "#000000";
        that.lineWidth = 16.0;
        const joins = [ "miter", "bevel", "round" ];
        for ( let index = 0; index < 3; ++index )
        {
            const left = ( index + 0.25 ) / 3.0 * width;
            const right = ( index + 0.75 ) / 3.0 * width;
            that.beginPath();
            that.moveTo( left, 0.2 * height );
            that.lineTo( left, 0.1 * height );
            that.lineTo( left, 0.2 * height );
            that.lineTo( right, 0.2 * height );
            that.lineTo( left, 0.2 * height );
            that.lineTo( left, 0.3 * height );
            that.lineTo( right, 0.3 * height );
            that.lineTo( right, 0.4 * height );
            that.lineTo( right, 0.5 * height );
            that.lineTo( left, 0.4 * height );
            that.lineTo( left, 0.5 * height );
            that.lineTo( right, 0.6 * height );
            that.bezierCurveTo( right, height,
                                left, 0.4 * height,
                                left, 0.7 * height );
            that.bezierCurveTo( left, 0.8 * height,
                                right, 0.8 * height,
                                right, 0.9 * height );
            that.lineJoin = joins[ index ];
            that.stroke();
        }
    } );
</script>
</div>

<div class="test-container">
<h2>line_<wbr>join_<wbr>offscreen</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<canvas id="line_join_offscreen_browser" width="256" height="256"></canvas>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="line_join_offscreen_wasm" width="256" height="256"></canvas>
</div>
</div>
<script type="text/javascript">
    window.addEventListener( "load", function( event ) {
        const element = document.getElementById( "line_join_offscreen_browser" );
        const that = element.getContext( "2d" );
        const width = element.width;
        const height = element.height;
        that.strokeStyle = "#000000";
        that.lineWidth = 36.0;
        const joins = [ "miter", "bevel", "round" ];
        for ( let index = 0; index < 3; ++index )
        {
            const x = ( index + 0.5 ) / 3.0 * width;
            const y = ( index + 0.5 ) / 3.0 * height;
            that.beginPath();
            that.moveTo( x - 10.0, -55.0 );
            that.lineTo( x - 10.0, -5.0 );
            that.lineTo( x + 10.0, -55.0 );
            that.moveTo( x - 10.0, height + 130.0 );
            that.lineTo( x + 10.0, height + 80.0 );
            that.lineTo( x + 10.0, height + 130.0 );
            that.moveTo( -130.0, y - 10.0 );
            that.lineTo( -80.0, y - 10.0 );
            that.lineTo( -130.0, y + 10.0 );
            that.moveTo( height + 55.0, y - 10.0 );
            that.lineTo( height + 5.0, y + 10.0 );
            that.lineTo( height + 55.0, y + 10.0 );
            that.lineJoin = joins[ index ];
            that.stroke();
        }
    } );
</script>
</div>

<div class="test-container">
<h2>miter_<wbr>limit</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<canvas id="miter_limit_browser" width="256" height="256"></canvas>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="miter_limit_wasm" width="256" height="256"></canvas>
</div>
</div>
<script type="text/javascript">
    window.addEventListener( "load", function( event ) {
        const element = document.getElementById( "miter_limit_browser" );
        const that = element.getContext( "2d" );
        const width = element.width;
        const height = element.height;
        that.strokeStyle = "#000000";
        for ( let line = 0.0; line < 4.0; line += 1.0 )
        {
            that.lineWidth = 1.5 * line + 1.0;
            that.miterLimit = 20.0;
            for ( let limit = 0.0; limit < 8.0; limit += 1.0 )
            {
                const left = ( limit + 0.2 ) / 8.0 * width;
                const middle = ( limit + 0.5 ) / 8.0 * width;
                const right = ( limit + 0.7 ) / 8.0 * width;
                const top = ( line + 0.3 ) / 4.0 * height;
                const bottom = ( line + 0.7 ) / 4.0 * height;
                that.beginPath();
                that.moveTo( left, bottom );
                that.lineTo( left, top );
                that.lineTo( right, bottom );
                that.lineTo( middle, top );
                that.miterLimit = 1.5 * limit;
                that.stroke();
            }
        }
    } );
</script>
</div>

<div class="test-container">
<h2>line_<wbr>dash_<wbr>offset</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<canvas id="line_dash_offset_browser" width="256" height="256"></canvas>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="line_dash_offset_wasm" width="256" height="256"></canvas>
</div>
</div>
<script type="text/javascript">
    window.addEventListener( "load", function( event ) {
        const element = document.getElementById( "line_dash_offset_browser" );
        const that = element.getContext( "2d" );
        const width = element.width;
        const height = element.height;
        that.strokeStyle = "#000000";
        that.lineWidth = 6.0;
        that.setLineDash( [ 20.0, 8.0, 8.0, 8.0 ] );
        for ( let step = 0.0; step < 16.0; step += 1.0 )
        {
            const left = ( step + 0.125 ) / 16.0 * width;
            const right = ( step + 0.875 ) / 16.0 * width;
            that.beginPath();
            that.moveTo( left, 0.0 );
            that.lineTo( right, 0.125 * height );
            that.lineTo( left, 0.375 * height );
            that.lineTo( right, 0.625 * height );
            that.lineTo( left, 0.875 * height );
            that.lineTo( right, height );
            that.lineDashOffset = ( step / 16.0 - 0.5 ) * 44.0;
            that.stroke();
        }
    } );
</script>
</div>

<div class="test-container">
<h2>line_<wbr>dash</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<canvas id="line_dash_browser" width="256" height="256"></canvas>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="line_dash_wasm" width="256" height="256"></canvas>
</div>
</div>
<script type="text/javascript">
    window.addEventListener( "load", function( event ) {
        const element = document.getElementById( "line_dash_browser" );
        const that = element.getContext( "2d" );
        const width = element.width;
        const height = element.height;
        that.strokeStyle = "#000000";
        that.lineWidth = 6.0;
        that.setLineDash( [ 10.0 ] );
        that.stroke();
        that.moveTo( 0.0, 0.0 );
        that.stroke();
        that.beginPath();
        that.moveTo( width * 0.25, 0.0 );
        that.lineTo( width * 0.25, height );
        that.stroke();
        that.setLineDash( [ 20.0, -8.0 ] );
        that.beginPath();
        that.moveTo( width * 0.375, 0.0 );
        that.lineTo( width * 0.375, height );
        that.stroke();
        that.setLineDash( [ 20.0, 8.0, 8.0, 8.0 ] );
        that.beginPath();
        that.moveTo( width * 0.5, 0.0 );
        that.lineTo( width * 0.5, height );
        that.stroke();
        that.setLineDash( [ 0.0, 8.0, 2.0, 8.0 ] );
        that.beginPath();
        that.moveTo( width * 0.625, 0.0 );
        that.lineTo( width * 0.625, height );
        that.stroke();
        that.setLineDash( [] );
        that.beginPath();
        that.moveTo( width * 0.75, 0.0 );
        that.lineTo( width * 0.75, height );
        that.stroke();
    } );
</script>
</div>

<div class="test-container">
<h2>line_<wbr>dash_<wbr>closed</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<canvas id="line_dash_closed_browser" width="256" height="256"></canvas>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="line_dash_closed_wasm" width="256" height="256"></canvas>
</div>
</div>
<script type="text/javascript">
    window.addEventListener( "load", function( event ) {
        const element = document.getElementById( "line_dash_closed_browser" );
        const that = element.getContext( "2d" );
        const width = element.width;
        const height = element.height;
        that.strokeStyle = "#000000";
        that.lineWidth = 32.0;
        that.setLineDash( [ 96.0, 32.0 ] );
        that.lineDashOffset = -80.0;
        that.strokeRect( 0.25 * width, 0.25 * height,
                         0.5 * width, 0.5 * height );
        that.setLineDash( [ 96.0, 32.0, 1024.0, 16.0 ] );
        that.lineDashOffset = 128.0;
        that.strokeRect( 0.09375 * width, 0.09375 * height,
                         0.8125 * width, 0.8125 * height );
    } );
</script>
</div>

<div class="test-container">
<h2>line_<wbr>dash_<wbr>overlap</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<canvas id="line_dash_overlap_browser" width="256" height="256"></canvas>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="line_dash_overlap_wasm" width="256" height="256"></canvas>
</div>
</div>
<script type="text/javascript">
    window.addEventListener( "load", function( event ) {
        const element = document.getElementById( "line_dash_overlap_browser" );
        const that = element.getContext( "2d" );
        const width = element.width;
        const height = element.height;
        that.strokeStyle = "#000000";
        that.fillStyle = "#ff0000";
        that.lineCap = "round";
        that.lineWidth = 16.0;
        that.setLineDash( [ 14.0, 12.0 ] );
        for ( let index = 0; index < 4; ++index )
        {
            const flip = ( index == 3 ? -1.0 : 1.0 );
            const topY = ( index & 1 ? 0.25 : 0.1 ) * height;
            const bottomY = ( index & 1 ? 0.9 : 0.75 ) * height;
            const midX = ( index & 2 ? 0.75 : 0.25 ) * width;
            const topWidth = ( index & 1 ? 0.25 : 0.55 ) * flip * width;
            const bottomWidth = ( index & 1 ? 0.55 : 0.25 ) * flip * width;
            that.moveTo( midX, topY );
            that.bezierCurveTo( midX - topWidth, topY,
                                midX + bottomWidth, bottomY,
                                midX, bottomY );
            that.bezierCurveTo( midX - bottomWidth, bottomY,
                                midX + topWidth, topY,
                                midX, topY );
            that.closePath();
        }
        that.fill();
        that.stroke();
    } );
</script>
</div>

<div class="test-container">
<h2>line_<wbr>dash_<wbr>offscreen</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<canvas id="line_dash_offscreen_browser" width="256" height="256"></canvas>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="line_dash_offscreen_wasm" width="256" height="256"></canvas>
</div>
</div>
<script type="text/javascript">
    window.addEventListener( "load", function( event ) {
        const element = document.getElementById( "line_dash_offscreen_browser" );
        const that = element.getContext( "2d" );
        const width = element.width;
        const height = element.height;
        that.strokeStyle = "#000000";
        that.lineWidth = 6.0;
        that.setLineDash( [
            0.0, width * 20.5 * 3.14159265 - height * 0.5 + 1.0,
            height - 2.0, 0.0 ] );
        for ( let step = -2.0; step <= 2.0; step += 1.0 )
        {
            that.beginPath();
            that.arc( width * -20.0, height * 0.5,
                      width * ( 20.5 - step * 0.1 ),
                      3.14159265, 1.5707963268 );
            that.lineDashOffset = width * step * 0.1 * 3.14159265;
            that.stroke();
        }
    } );
</script>
</div>

<div class="test-container">
<h2>color</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<canvas id="color_browser" width="256" height="256"></canvas>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="color_wasm" width="256" height="256"></canvas>
</div>
</div>
<script type="text/javascript">
    window.addEventListener( "load", function( event ) {
        const element = document.getElementById( "color_browser" );
        const that = element.getContext( "2d" );
        const width = element.width;
        const height = element.height;
        const radius = Math.min( width, height ) * 0.4;
        that.fillStyle = "rgba(510,-255,0,0.5)";
        that.strokeStyle = "rgba(0,0,255,1.5)";
        that.lineWidth = 16.0;
        that.arc( 0.5 * width, 0.5 * height, radius, 0.0, 6.28318531 );
        that.closePath();
        that.fill();
        that.stroke();
    } );
</script>
</div>

<div class="test-container">
<h2>linear_<wbr>gradient</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<canvas id="linear_gradient_browser" width="256" height="256"></canvas>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="linear_gradient_wasm" width="256" height="256"></canvas>
</div>
</div>
<script type="text/javascript">
    window.addEventListener( "load", function( event ) {
        const element = document.getElementById( "linear_gradient_browser" );
        const that = element.getContext( "2d" );
        const width = element.width;
        const height = element.height;
        const radius = Math.min( width, height ) * 0.4;
        let gradient = that.createLinearGradient( 0.3 * width, 0.3 * height,
                                                  0.7 * width, 0.7 * height );
        gradient.addColorStop( 0.0, "rgba(0,255,0,0.5)" );
        gradient.addColorStop( 1.0, "rgba(255,0,255,100.0)" );
        that.fillStyle = gradient;
        gradient = that.createLinearGradient( 0.3 * width, 0.7 * height,
                                              0.7 * width, 0.3 * height );
        gradient.addColorStop( 0.0, "rgba(0,0,255,0.5)" );
        gradient.addColorStop( 1.0, "#ffff00" );
        that.strokeStyle = gradient;
        that.lineWidth = 16.0;
        that.arc( 0.5 * width, 0.5 * height, radius, 0.0, 6.28318531 );
        that.closePath();
        that.fill();
        that.stroke();
        gradient = that.createLinearGradient( 0.5 * width, 0.5 * height,
                                              0.5 * width, 0.5 * height );
        gradient.addColorStop( 0.0, "rgba(255,0,0,0.5)" );
        gradient.addColorStop( 1.0, "#00ffff" );
        that.strokeStyle = gradient;
        that.stroke();
    } );
</script>
</div>

<div class="test-container">
<h2>radial_<wbr>gradient</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<canvas id="radial_gradient_browser" width="256" height="256"></canvas>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="radial_gradient_wasm" width="256" height="256"></canvas>
</div>
</div>
<script type="text/javascript">
    window.addEventListener( "load", function( event ) {
        const element = document.getElementById( "radial_gradient_browser" );
        const that = element.getContext( "2d" );
        const width = element.width;
        const height = element.height;
        const radius = Math.min( width, height ) * 0.4;
        let gradient = that.createRadialGradient( 0.0, 0.0, radius,
                                                  width, height, 0.5 * radius );
        gradient.addColorStop( 0.0, "rgba(0,255,0,0.5)" );
        gradient.addColorStop( 1.0, "#ff00ff" );
        that.fillStyle = gradient;
        gradient = that.createRadialGradient( 0.0, height, radius,
                                              width, 0.0, 0.5 * radius );
        gradient.addColorStop( 0.0, "rgba(0,0,255,0.5)" );
        gradient.addColorStop( 1.0, "#ffff00" );
        that.strokeStyle = gradient;
        that.lineWidth = 16.0;
        that.arc( 0.5 * width, 0.5 * height, radius, 0.0, 6.28318531 );
        that.closePath();
        that.fill();
        that.stroke();
        gradient = that.createRadialGradient( 0.5 * width, 0.4 * height, 10.0,
                                              0.5 * width, 0.6 * height, 0.0 );
        try {
            gradient = that.createRadialGradient( 0.0, 0.5 * height, -10.0,
                                                  width, 0.5 * height, 10.0 );
        } catch ( error ) {}
        gradient.addColorStop( 0.0, "rgba(255,0,0,0.5)" );
        gradient.addColorStop( 1.0, "#00ffff" );
        that.strokeStyle = gradient;
        that.stroke();
        gradient = that.createRadialGradient( 0.5 * width, 0.5 * height, 0.0,
                                              0.5 * width, 0.5 * height, radius );
        gradient.addColorStop( 0.15, "#000000" );
        gradient.addColorStop( 0.20, "rgba(0,0,0,0.0)" );
        that.fillStyle = gradient;
        that.fill();
    } );
</script>
</div>

<div class="test-container">
<h2>conic_<wbr>gradient</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<div class="placeholder" style="width:256px;height:256px;">Extension test</div>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="conic_gradient_wasm" width="256" height="256"></canvas>
</div>
</div>
</div>

<div class="test-container">
<h2>conic_<wbr>gradient_<wbr>rect</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<div class="placeholder" style="width:256px;height:256px;">Extension test</div>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="conic_gradient_rect_wasm" width="256" height="256"></canvas>
</div>
</div>
</div>

<div class="test-container">
<h2>color_<wbr>stop</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<canvas id="color_stop_browser" width="256" height="256"></canvas>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="color_stop_wasm" width="256" height="256"></canvas>
</div>
</div>
<script type="text/javascript">
    window.addEventListener( "load", function( event ) {
        const element = document.getElementById( "color_stop_browser" );
        const that = element.getContext( "2d" );
        const width = element.width;
        const height = element.height;
        const gradient = that.createLinearGradient( 0.1 * width, 0.0,
                                                    0.9 * width, 0.0 );
        that.fillStyle = gradient;
        that.fillRect( 0.0, 0.0, width, 0.1 * height );
        try {
            gradient.addColorStop( -1.0, "#00ff00" );
            gradient.addColorStop( 2.0, "#ff0000" );
        } catch ( error ) {}
        gradient.addColorStop( 0.3, "rgba(-255,0,510,2.0)" );
        gradient.addColorStop( 0.3, "#ffffff" );
        gradient.addColorStop( 0.3, "#000000" );
        gradient.addColorStop( 0.0, "#0000cc" );
        gradient.addColorStop( 1.0, "#ffffff" );
        gradient.addColorStop( 0.7, "#e6e6e6" );
        gradient.addColorStop( 0.6, "#1a1a1a" );
        that.fillRect( 0.0, 0.1 * height, width,  0.4 * height );
        that.fillStyle = gradient;
        that.fillRect( 0.0, 0.5 * height, width, 0.4 * height );
    } );
</script>
</div>

<div class="test-container">
<h2>pattern</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<canvas id="pattern_browser" width="256" height="256"></canvas>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="pattern_wasm" width="256" height="256"></canvas>
</div>
</div>
<script type="text/javascript">
    window.addEventListener( "load", function( event ) {
        const element = document.getElementById( "pattern_browser" );
        const that = element.getContext( "2d" );
        const width = element.width;
        const height = element.height;
        const checker = new Uint8ClampedArray( 256 );
        for ( let index = 0; index < 256; ++index )
            checker[ index ] =
                ( ( ( index >> 2 & 1 ) ^ ( index >> 5 & 1 ) ) |
                  ( ( index & 3 ) == 3 ) ) * 255;
        const image = document.createElement( "canvas" );
        image.width = 8;
        image.height = 8;
        image.getContext( "2d" ).putImageData(
            new ImageData( checker, 8, 8 ), 0, 0 );
        that.arc( 0.5 * width, 0.5 * height, 32.0, 0.0, 6.28318531 );
        that.closePath();
        that.lineWidth = 20.0;
        that.strokeStyle = "#000000";
        try {
            that.strokeStyle = that.createPattern( null, "repeat" );
        } catch ( error ) {}
        that.stroke();
        that.lineWidth = 16.0;
        that.strokeStyle = that.createPattern( image, "repeat" );
        that.stroke();
        for ( let scale = 8.0; scale >= 1.0; scale /= 2.0 )
        {
            that.setTransform( 1.0, 0.0, 0.0, 1.0, 0.0, 0.0 );
            that.scale( scale, scale );
            const sizeX = 0.5 * width / scale;
            const sizeY = 0.5 * height / scale;
            that.fillStyle = that.createPattern( image, "no-repeat" );
            that.fillRect( 0.0, 0.0, sizeX, sizeY );
            that.fillStyle = that.createPattern( image, "repeat-x" );
            that.fillRect( sizeX, 0.0, sizeX, sizeY );
            that.fillStyle = that.createPattern( image, "repeat-y" );
            that.fillRect( 0.0, sizeY, sizeX, sizeY );
            that.fillStyle = that.createPattern( image, "repeat" );
            that.fillRect( sizeX, sizeY, sizeX, sizeY );
        }
    } );
</script>
</div>

<div class="test-container">
<h2>begin_<wbr>path</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<canvas id="begin_path_browser" width="256" height="256"></canvas>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="begin_path_wasm" width="256" height="256"></canvas>
</div>
</div>
<script type="text/javascript">
    window.addEventListener( "load", function( event ) {
        const element = document.getElementById( "begin_path_browser" );
        const that = element.getContext( "2d" );
        const width = element.width;
        const height = element.height;
        that.moveTo( 0.0, 0.0 );
        that.lineTo( width, height );
        that.stroke();
        that.strokeStyle = "#000000";
        that.beginPath();
        that.beginPath();
        that.moveTo( width, 0.0 );
        that.lineTo( 0.0, height );
        that.stroke();
        that.beginPath();
        that.lineTo( 0.5 * width, height );
        that.stroke();
    } );
</script>
</div>

<div class="test-container">
<h2>move_<wbr>to</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<canvas id="move_to_browser" width="256" height="256"></canvas>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="move_to_wasm" width="256" height="256"></canvas>
</div>
</div>
<script type="text/javascript">
    window.addEventListener( "load", function( event ) {
        const element = document.getElementById( "move_to_browser" );
        const that = element.getContext( "2d" );
        const width = element.width;
        const height = element.height;
        that.strokeStyle = "#000000";
        that.fillStyle = "#ff0000";
        that.lineWidth = 8.0;
        that.moveTo( 0.6 * width, height );
        that.moveTo( 0.4 * width, 0.1 * height );
        that.lineTo( 0.2 * width, 0.5 * height );
        that.lineTo( 0.4 * width, 0.9 * height );
        that.moveTo( 0.6 * width, 0.2 * height );
        that.lineTo( 0.8 * width, 0.4 * height );
        that.moveTo( 0.8 * width, 0.6 * height );
        that.lineTo( 0.6 * width, 0.8 * height );
        that.moveTo( 0.7 * width, 0.5 * height );
        that.lineTo( 0.7 * width, 0.5 * height );
        that.fill();
        that.stroke();
    } );
</script>
</div>

<div class="test-container">
<h2>close_<wbr>path</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<canvas id="close_path_browser" width="256" height="256"></canvas>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="close_path_wasm" width="256" height="256"></canvas>
</div>
</div>
<script type="text/javascript">
    window.addEventListener( "load", function( event ) {
        const element = document.getElementById( "close_path_browser" );
        const that = element.getContext( "2d" );
        const width = element.width;
        const height = element.height;
        that.strokeStyle = "#000000";
        that.fillStyle = "#ff0000";
        that.lineWidth = 8.0;
        that.closePath();
        that.lineTo( 0.5 * width, 0.5 * height );
        that.lineTo( 0.2 * width, 0.8 * height );
        that.lineTo( 0.2 * width, 0.2 * height );
        that.closePath();
        that.lineTo( 0.5 * width, 0.2 * height );
        that.lineTo( 0.8 * width, 0.2 * height );
        that.closePath();
        that.closePath();
        that.moveTo( 0.5 * width, 0.8 * height );
        that.lineTo( 0.8 * width, 0.8 * height );
        that.lineTo( 0.8 * width, 0.5 * height );
        that.closePath();
        that.fill();
        that.stroke();
    } );
</script>
</div>

<div class="test-container">
<h2>line_<wbr>to</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<canvas id="line_to_browser" width="256" height="256"></canvas>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="line_to_wasm" width="256" height="256"></canvas>
</div>
</div>
<script type="text/javascript">
    window.addEventListener( "load", function( event ) {
        const element = document.getElementById( "line_to_browser" );
        const that = element.getContext( "2d" );
        const width = element.width;
        const height = element.height;
        that.strokeStyle = "#000000";
        that.fillStyle = "#ff0000";
        that.lineWidth = 16.0;
        that.lineTo( 0.1 * width, 0.2 * height );
        that.lineTo( 0.1 * width, 0.2 * height );
        that.lineTo( 0.2 * width, 0.5 * height );
        that.lineTo( 0.2 * width, 0.5 * height );
        that.lineTo( 0.3 * width, 0.8 * height );
        that.lineTo( 0.4 * width, 0.2 * height );
        that.lineTo( 0.4 * width, 0.2 * height );
        that.lineTo( 0.6 * width, 0.8 * height );
        that.lineTo( 0.6 * width, 0.8 * height );
        that.moveTo( 0.7 * width, 0.4 * height );
        that.lineTo( 0.9 * width, 0.4 * height );
        that.lineTo( 0.9 * width, 0.6 * height );
        that.lineTo( 0.7 * width, 0.6 * height );
        that.lineTo( 0.7 * width, 0.4 * height );
        that.fill();
        that.stroke();
    } );
</script>
</div>

<div class="test-container">
<h2>quadratic_<wbr>curve_<wbr>to</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<canvas id="quadratic_curve_to_browser" width="256" height="256"></canvas>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="quadratic_curve_to_wasm" width="256" height="256"></canvas>
</div>
</div>
<script type="text/javascript">
    window.addEventListener( "load", function( event ) {
        const element = document.getElementById( "quadratic_curve_to_browser" );
        const that = element.getContext( "2d" );
        const width = element.width;
        const height = element.height;
        that.strokeStyle = "#000000";
        that.fillStyle = "#ff0000";
        that.lineWidth = 8.0;
        that.quadraticCurveTo( 0.1 * width, 0.2 * height,
                               0.1 * width, 0.2 * height );
        that.quadraticCurveTo( 0.2 * width, 0.5 * height,
                               0.2 * width, 0.5 * height );
        that.quadraticCurveTo( 0.3 * width, 0.8 * height,
                               0.4 * width, 0.2 * height );
        that.quadraticCurveTo( 0.6 * width, 0.8 * height,
                               0.7 * width, 0.2 * height );
        that.moveTo( 0.7 * width, 0.6 * height );
        that.quadraticCurveTo( 0.9 * width, 0.6 * height,
                               0.9 * width, 0.8 * height );
        that.quadraticCurveTo( 0.9 * width, 0.9 * height,
                               0.7 * width, 0.9 * height );
        that.closePath();
        that.moveTo( 0.1 * width, 0.9 * height );
        that.quadraticCurveTo( 0.5 * width, 0.5 * height,
                               0.1 * width, 0.9 * height );
        that.fill();
        that.stroke();
    } );
</script>
</div>

<div class="test-container">
<h2>bezier_<wbr>curve_<wbr>to</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<canvas id="bezier_curve_to_browser" width="256" height="256"></canvas>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="bezier_curve_to_wasm" width="256" height="256"></canvas>
</div>
</div>
<script type="text/javascript">
    window.addEventListener( "load", function( event ) {
        const element = document.getElementById( "bezier_curve_to_browser" );
        const that = element.getContext( "2d" );
        const width = element.width;
        const height = element.height;
        that.strokeStyle = "#000000";
        that.fillStyle = "#ff0000";
        that.lineWidth = 8.0;
        that.bezierCurveTo( 0.9 * width, 0.9 * height,
                            0.6 * width, 0.6 * height,
                            0.6 * width, 0.9 * height );
        that.moveTo( 0.1 * width, 0.1 * height );
        that.bezierCurveTo( 0.9 * width, 0.9 * height,
                            0.9 * width, 0.1 * height,
                            0.1 * width, 0.9 * height );
        that.moveTo( 0.4 * width, 0.1 * height );
        that.bezierCurveTo( 0.1 * width, 0.3 * height,
                            0.7 * width, 0.3 * height,
                            0.4 * width, 0.1 * height );
        that.moveTo( 0.9 * width, 0.1 * height );
        that.bezierCurveTo( 0.6 * width, 0.2 * height,
                            0.9 * width, 0.1 * height,
                            0.6 * width, 0.2 * height );
        that.moveTo( 0.7 * width, 0.3 * height );
        that.bezierCurveTo( 0.9 * width, 0.3 * height,
                            0.9 * width, 0.4 * height,
                            0.8 * width, 0.5 * height );
        that.bezierCurveTo( 0.7 * width, 0.6 * height,
                            0.7 * width, 0.7 * height,
                            0.9 * width, 0.7 * height );
        that.fill();
        that.stroke();
    } );
</script>
</div>

<div class="test-container">
<h2>arc_<wbr>to</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<canvas id="arc_to_browser" width="256" height="256"></canvas>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="arc_to_wasm" width="256" height="256"></canvas>
</div>
</div>
<script type="text/javascript">
    window.addEventListener( "load", function( event ) {
        const element = document.getElementById( "arc_to_browser" );
        const that = element.getContext( "2d" );
        const width = element.width;
        const height = element.height;
        const radius = Math.min( width, height ) * 0.5;
        that.strokeStyle = "#000000";
        that.fillStyle = "#ff0000";
        that.lineWidth = 8.0;
        that.arcTo( 0.3 * width, 0.3 * height,
                    0.5 * width, 0.5 * height, 16.0 );
        that.moveTo( 0.4 * width, 0.4 * height );
        that.arcTo( 0.7 * width, 0.1 * height,
                    0.7 * width, 0.4 * height, 0.0 );
        that.arcTo( 0.9 * width, 0.5 * height,
                    0.7 * width, 0.7 * height, 0.125 * radius );
        that.arcTo( 0.5 * width, 0.9 * height,
                    0.3 * width, 0.8 * height, 0.25 * radius );
        that.arcTo( 0.1 * width, 0.7 * height,
                    0.4 * width, 0.4 * height, 0.375 * radius );
        that.closePath();
        that.moveTo( 0.1 * width, 0.6 * height );
        that.transform( 1.0, -1.0, 0.0, 1.0, 0.0, 0.2 * height );
        that.arcTo( 0.1 * width, 0.9 * height,
                    0.5 * width, 0.9 * height, 0.3 * radius );
        that.setTransform( 1.0, 0.0, 0.0, 1.0, 0.0, 0.0 );
        that.closePath();
        that.moveTo( 0.2 * width, 0.1 * height );
        that.arcTo( 0.1 * width, 0.1 * height,
                    0.1 * width, 0.7 * height, 0.6 * radius );
        that.arcTo( 0.2 * width, 0.4 * height,
                    0.2 * width, 0.4 * height, 0.5 * radius );
        that.arcTo( 0.4 * width, 0.2 * height,
                    0.2 * width, 0.4 * height, 0.5 * radius );
        try {
            that.arcTo( 0.5 * width, 0.5 * height,
                        0.9 * width, 0.1 * height, -1.0 );
        } catch ( error ) {}
        that.moveTo( 0.6 * width, 0.9 * height );
        that.setTransform( 0.0, 0.0, 0.0, 1.0, 0.9 * width, 0.0 );
        that.arcTo( 0.9 * width, 0.9 * height,
                    0.9 * width, 0.6 * height, 0.3 * radius );
        that.setTransform( 1.0, 0.0, 0.0, 1.0, 0.0, 0.0 );
        that.arcTo( 0.9 * width, 0.6 * height,
                    0.9 * width, 0.6 * height, 0.0 );
        that.fill();
        that.stroke();
    } );
</script>
</div>

<div class="test-container">
<h2>arc</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<canvas id="arc_browser" width="256" height="256"></canvas>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="arc_wasm" width="256" height="256"></canvas>
</div>
</div>
<script type="text/javascript">
    window.addEventListener( "load", function( event ) {
        const element = document.getElementById( "arc_browser" );
        const that = element.getContext( "2d" );
        const width = element.width;
        const height = element.height;
        that.strokeStyle = "#000000";
        that.fillStyle = "#ff0000";
        that.lineWidth = 8.0;
        for ( let i = 0; i < 4; ++i )
            for ( let j = 0; j < 3; ++j )
            {
                const x = ( j + 0.5 ) * width / 3.0;
                const y = ( i + 0.5 ) * height / 4.0;
                const radius = Math.min( width, height ) * 0.1;
                const start = ( 3.14159265 + 1.0e-6 ) * ( i % 2 );
                const end = ( 3.14159265 + 1.0e-6 ) * ( 1.0 + 0.5 * j );
                const counter = Math.trunc( i / 2 );
                that.beginPath();
                try {
                    that.arc( x, y, -radius, start, end, counter );
                } catch ( error ) {}
                that.arc( x, y, radius, start, end, counter );
                that.closePath();
                that.fill();
                that.stroke();
            }
    } );
</script>
</div>

<div class="test-container">
<h2>ellipse</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<div class="placeholder" style="width:256px;height:256px;">Extension test</div>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="ellipse_wasm" width="256" height="256"></canvas>
</div>
</div>
</div>

<div class="test-container">
<h2>ellipse_<wbr>rotated</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<div class="placeholder" style="width:256px;height:256px;">Extension test</div>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="ellipse_rotated_wasm" width="256" height="256"></canvas>
</div>
</div>
</div>

<div class="test-container">
<h2>rectangle</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<canvas id="rectangle_browser" width="256" height="256"></canvas>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="rectangle_wasm" width="256" height="256"></canvas>
</div>
</div>
<script type="text/javascript">
    window.addEventListener( "load", function( event ) {
        const element = document.getElementById( "rectangle_browser" );
        const that = element.getContext( "2d" );
        const width = element.width;
        const height = element.height;
        that.strokeStyle = "#000000";
        that.fillStyle = "#ff0000";
        that.lineWidth = 8.0;
        that.moveTo( 0.3 * width, 0.3 * height );
        that.lineTo( 0.7 * width, 0.3 * height );
        that.lineTo( 0.7 * width, 0.7 * height );
        that.lineTo( 0.3 * width, 0.7 * height );
        that.closePath();
        that.moveTo( 0.0, 0.0 );
        for ( let y = -1.0; y <= 1.0; y += 1.0 )
            for ( let x = -1.0; x <= 1.0; x += 1.0 )
                that.rect( ( 0.5 + 0.1 * x ) * width,
                           ( 0.5 + 0.1 * y ) * height,
                           x * 0.3 * width, y * 0.3 * height );
        that.lineTo( width, height );
        that.fill();
        that.stroke();
    } );
</script>
</div>

<div class="test-container">
<h2>round_<wbr>rect</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<div class="placeholder" style="width:256px;height:256px;">Extension test</div>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="round_rect_wasm" width="256" height="256"></canvas>
</div>
</div>
</div>

<div class="test-container">
<h2>round_<wbr>rect_<wbr>clamped</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<div class="placeholder" style="width:256px;height:256px;">Extension test</div>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="round_rect_clamped_wasm" width="256" height="256"></canvas>
</div>
</div>
</div>

<div class="test-container">
<h2>fill</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<canvas id="fill_browser" width="256" height="256"></canvas>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="fill_wasm" width="256" height="256"></canvas>
</div>
</div>
<script type="text/javascript">
    window.addEventListener( "load", function( event ) {
        const element = document.getElementById( "fill_browser" );
        const that = element.getContext( "2d" );
        const width = element.width;
        const height = element.height;
        const radius = Math.min( width, height ) * 0.45;
        that.fillStyle = "#000000";
        that.fill();
        that.beginPath();
        for ( let step = 0.0; step < 128.0; step += 1.0 )
        {
            const angle = step * ( 59.0 / 128.0 * 6.28318531 );
            const x = Math.cos( angle ) * radius + width / 2.0;
            const y = Math.sin( angle ) * radius + height / 2.0;
            that.lineTo( x, y );
        }
        that.closePath();
        that.fill();
        that.fillStyle = "#ff0000";
        that.scale( 0.0, 1.0 );
        that.fill();
    } );
</script>
</div>

<div class="test-container">
<h2>fill_<wbr>rounding</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<canvas id="fill_rounding_browser" width="256" height="256"></canvas>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="fill_rounding_wasm" width="256" height="256"></canvas>
</div>
</div>
<script type="text/javascript">
    window.addEventListener( "load", function( event ) {
        const element = document.getElementById( "fill_rounding_browser" );
        const that = element.getContext( "2d" );
        const width = element.width;
        const height = element.height;
        that.fillStyle = "#000000";
        that.beginPath();
        that.moveTo( 4.00000191, 4.00000763 );
        that.lineTo( 3.99999809, 192.0 );
        that.lineTo( 28.0000019, 192.0 );
        that.closePath();
        that.moveTo( -10390.0664, 52.3311195 );
        that.lineTo( -10389.9941, 47.6248589 );
        that.lineTo( -10395.9941, 47.5328255 );
        that.lineTo( -10396.0664, 52.2478294 );
        that.closePath();
        that.moveTo( 110.0, 256.0 );
        that.lineTo( 124.086205, 255.998276 );
        that.lineTo( 123.203453, 0.0 );
        that.closePath();
        that.fill();
    } );
</script>
</div>

<div class="test-container">
<h2>fill_<wbr>converging</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<canvas id="fill_converging_browser" width="256" height="256"></canvas>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="fill_converging_wasm" width="256" height="256"></canvas>
</div>
</div>
<script type="text/javascript">
    window.addEventListener( "load", function( event ) {
        const element = document.getElementById( "fill_converging_browser" );
        const that = element.getContext( "2d" );
        const width = element.width;
        const height = element.height;
        const radius = Math.min( width, height ) * 0.48;
        that.fillStyle = "#000000";
        for ( let step = 0.0; step < 256.0; step += 1.0 )
        {
            const angle1 = ( step + 0.0 ) / 256.0 * 6.28318531;
            const angle2 = ( step + 0.5 ) / 256.0 * 6.28318531;
            that.moveTo( width / 2.0 + 0.5, height / 2.0 + 0.5 );
            that.lineTo( Math.cos( angle1 ) * radius + width  / 2.0 + 0.5,
                         Math.sin( angle1 ) * radius + height / 2.0 + 0.5 );
            that.lineTo( Math.cos( angle2 ) * radius + width  / 2.0 + 0.5,
                         Math.sin( angle2 ) * radius + height / 2.0 + 0.5 );
            that.closePath();
        }
        that.fill();
    } );
</script>
</div>

<div class="test-container">
<h2>fill_<wbr>zone_<wbr>plate</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<canvas id="fill_zone_plate_browser" width="256" height="256"></canvas>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="fill_zone_plate_wasm" width="256" height="256"></canvas>
</div>
</div>
<script type="text/javascript">
    window.addEventListener( "load", function( event ) {
        const element = document.getElementById( "fill_zone_plate_browser" );
        const that = element.getContext( "2d" );
        const width = element.width;
        const height = element.height;
        const radius = Math.floor( Math.min( width, height ) * 0.48 / 4.0 ) * 4.0;
        that.fillStyle = "#000000";
        for ( let step = 0.0; step < radius; step += 2.0 )
        {
            const inner = Math.sqrt( ( step + 0.0 ) / radius ) * radius;
            const outer = Math.sqrt( ( step + 1.0 ) / radius ) * radius;
            that.moveTo( width / 2.0 + inner, height / 2.0 );
            that.arc( width / 2.0, height / 2.0, inner,
                      0.0, 6.28318531 );
            that.closePath();
            that.moveTo( width / 2.0 + outer, height / 2.0 );
            that.arc( width / 2.0, height / 2.0, outer,
                      6.28318531, 0.0, true );
            that.closePath();
        }
        that.fill();
    } );
</script>
</div>

<div class="test-container">
<h2>stroke</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<canvas id="stroke_browser" width="256" height="256"></canvas>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="stroke_wasm" width="256" height="256"></canvas>
</div>
</div>
<script type="text/javascript">
    window.addEventListener( "load", function( event ) {
        const element = document.getElementById( "stroke_browser" );
        const that = element.getContext( "2d" );
        const width = element.width;
        const height = element.height;
        const radius = Math.min( width, height ) * 0.45;
        that.strokeStyle = "#000000";
        that.stroke();
        that.beginPath();
        for ( let step = 0.0; step < 128.0; step += 1.0 )
        {
            const angle = step * ( 59.0 / 128.0 * 6.28318531 );
            const x = Math.cos( angle ) * radius + width / 2.0;
            const y = Math.sin( angle ) * radius + height / 2.0;
            that.lineTo( x, y );
        }
        that.closePath();
        that.stroke();
        that.strokeStyle = "#ff0000";
        that.scale( 0.0, 1.0 );
        that.stroke();
    } );
</script>
</div>

<div class="test-container">
<h2>stroke_<wbr>wide</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<canvas id="stroke_wide_browser" width="256" height="256"></canvas>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="stroke_wide_wasm" width="256" height="256"></canvas>
</div>
</div>
<script type="text/javascript">
    window.addEventListener( "load", function( event ) {
        const element = document.getElementById( "stroke_wide_browser" );
        const that = element.getContext( "2d" );
        const width = element.width;
        const height = element.height;
        that.scale( width / 256.0, height / 256.0 );
        that.lineJoin = "round";
        that.moveTo( 24.0, 104.0 );
        that.bezierCurveTo( 112.0, 24.0, 16.0, 24.0, 104.0, 104.0 );
        that.moveTo( 152.0, 104.0 );
        that.bezierCurveTo( 232.8, 24.0, 151.2, 24.0, 232.0, 104.0 );
        that.moveTo( 24.0, 232.0 );
        that.bezierCurveTo( 104.0, 152.0, 24.0, 152.0, 104.0, 232.0 );
        that.moveTo( 188.0, 232.0 );
        that.bezierCurveTo( 196.0, 184.0, 188.0, 184.0, 196.0, 192.0 );
        that.lineWidth = 40.0;
        that.stroke();
        that.strokeStyle = "#ff0000";
        that.lineWidth = 1.0;
        that.stroke();
    } );
</script>
</div>

<div class="test-container">
<h2>stroke_<wbr>inner_<wbr>join</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<canvas id="stroke_inner_join_browser" width="256" height="256"></canvas>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="stroke_inner_join_wasm" width="256" height="256"></canvas>
</div>
</div>
<script type="text/javascript">
    window.addEventListener( "load", function( event ) {
        const element = document.getElementById( "stroke_inner_join_browser" );
        const that = element.getContext( "2d" );
        const width = element.width;
        const height = element.height;
        const joins = [ "miter", "bevel", "round" ];
        for ( let index = 0; index < 3; ++index )
        {
            const center = ( index + 0.5 ) / 3.0 * width;
            that.beginPath();
            that.moveTo( center - 0.05 * width, 0.275 * height );
            that.lineTo( center, 0.225 * height );
            that.lineTo( center + 0.025 * width, 0.25 * height );
            that.moveTo( center - 0.05 * width, 0.775 * height );
            that.bezierCurveTo( center, 0.725 * height,
                                center, 0.725 * height,
                                center + 0.025 * width, 0.75 * height );
            that.lineJoin = joins[ index ];
            that.strokeStyle = "#000000";
            that.lineWidth = 0.3 * width;
            that.stroke();
            that.strokeStyle = "#ff0000";
            that.lineWidth = 1.0;
            that.stroke();
        }
    } );
</script>
</div>

<div class="test-container">
<h2>stroke_<wbr>spiral</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<canvas id="stroke_spiral_browser" width="256" height="256"></canvas>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="stroke_spiral_wasm" width="256" height="256"></canvas>
</div>
</div>
<script type="text/javascript">
    window.addEventListener( "load", function( event ) {
        const element = document.getElementById( "stroke_spiral_browser" );
        const that = element.getContext( "2d" );
        const width = element.width;
        const height = element.height;
        that.strokeStyle = "#000000";
        that.lineWidth = 2.0;
        that.beginPath();
        const outside = Math.min( width, height ) * 0.48;
        for ( let step = 0.0; step <= 2048.0; step += 1.0 )
        {
            const parameter = ( step - 1024.0 ) / 1024.0;
            const angle = Math.abs( parameter ) * 12.0 * 6.28318531;
            const radius = parameter * outside;
            that.lineTo( Math.cos( angle ) * radius + width * 0.5,
                         Math.sin( angle ) * radius + height * 0.5 );
        }
        that.stroke();
    } );
</script>
</div>

<div class="test-container">
<h2>stroke_<wbr>long</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<canvas id="stroke_long_browser" width="256" height="256"></canvas>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="stroke_long_wasm" width="256" height="256"></canvas>
</div>
</div>
<script type="text/javascript">
    window.addEventListener( "load", function( event ) {
        const element = document.getElementById( "stroke_long_browser" );
        const that = element.getContext( "2d" );
        const width = element.width;
        const height = element.height;
        that.strokeStyle = "#000000";
        for ( let step = 0.0; step <= 29.0; step += 1.0 )
        {
            that.moveTo( 0.4 * width, -23.0 * height );
            that.lineTo( width * step / 29.0, height );
            that.moveTo( -23.0 * width, 0.4 * height );
            that.lineTo( width, height * step / 29.0 );
        }
        that.stroke();
    } );
</script>
</div>

<div class="test-container">
<h2>clip</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<canvas id="clip_browser" width="256" height="256"></canvas>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="clip_wasm" width="256" height="256"></canvas>
</div>
</div>
<script type="text/javascript">
    window.addEventListener( "load", function( event ) {
        const element = document.getElementById( "clip_browser" );
        const that = element.getContext( "2d" );
        const width = element.width;
        const height = element.height;
        const radius = Math.min( width, height ) * 0.5;
        that.lineWidth = 8.0;
        for ( let step = 0; step < 8; ++step )
        {
            const fraction = step / 8.0;
            const angle = fraction * 6.28318531;
            that.strokeStyle = step & 1 ? "#00ff00" : "#000000";
            that.beginPath();
            that.arc( 0.5 * width + 0.8 * radius * Math.cos( angle ),
                      0.5 * height + 0.8 * radius * Math.sin( angle ),
                      radius, 0.0, 6.28318531 );
            that.closePath();
            that.stroke();
            that.clip();
        }
        that.beginPath();
        that.clip();
        that.fillStyle = "#ff00ff";
        that.fillRect( 0.0, 0.0, width, height );
    } );
</script>
</div>

<div class="test-container">
<h2>clip_<wbr>winding</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<canvas id="clip_winding_browser" width="256" height="256"></canvas>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="clip_winding_wasm" width="256" height="256"></canvas>
</div>
</div>
<script type="text/javascript">
    window.addEventListener( "load", function( event ) {
        const element = document.getElementById( "clip_winding_browser" );
        const that = element.getContext( "2d" );
        const width = element.width;
        const height = element.height;
        that.moveTo( 0.125 * width, 0.125 * height );
        that.lineTo( 0.625 * width, 0.125 * height );
        that.lineTo( 0.625 * width, 0.625 * height );
        that.lineTo( 0.125 * width, 0.625 * height );
        that.moveTo( 0.250 * width, 0.250 * height );
        that.lineTo( 0.750 * width, 0.250 * height );
        that.lineTo( 0.750 * width, 0.750 * height );
        that.lineTo( 0.250 * width, 0.750 * height );
        that.moveTo( 0.375 * width, 0.375 * height );
        that.lineTo( 0.375 * width, 0.875 * height );
        that.lineTo( 0.875 * width, 0.875 * height );
        that.lineTo( 0.875 * width, 0.375 * height );
        that.fillStyle = "#ff0000";
        that.fill();
        that.clip();
        that.lineWidth = 4.0;
        that.stroke();
        that.lineWidth = 6.0;
        that.beginPath();
        for ( let step = 0.0; step < 32.0; step += 1.0 )
        {
            that.moveTo( step / 16.0 * width, 0.0 );
            that.lineTo( step / 16.0 * width - width, height );
        }
        that.stroke();
    } );
</script>
</div>

<div class="test-container">
<h2>is_<wbr>point_<wbr>in_<wbr>path</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<canvas id="is_point_in_path_browser" width="256" height="256"></canvas>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="is_point_in_path_wasm" width="256" height="256"></canvas>
</div>
</div>
<script type="text/javascript">
    window.addEventListener( "load", function( event ) {
        const element = document.getElementById( "is_point_in_path_browser" );
        const that = element.getContext( "2d" );
        const width = element.width;
        const height = element.height;
        that.fillStyle = "#0000ff";
        that.strokeStyle = "#ffffff";
        if ( that.isPointInPath( 0.0, 0.0 ) )
            that.fillRectangle( 0.0, 0.0, 16.0, 16.0 );
        that.scale( width / 256.0, height / 256.0 );
        that.beginPath();
        that.moveTo( 65.0, 16.0 );
        that.lineTo( 113.0, 24.0 );
        that.bezierCurveTo( 113.0, 24.0, 93.0, 126.0, 119.0, 160.0 );
        that.bezierCurveTo( 133.0, 180.0, 170.0, 196.0, 186.0, 177.0 );
        that.bezierCurveTo( 198.0, 162.0, 182.0, 130.0, 166.0, 118.0 );
        that.bezierCurveTo( 123.0, 80.0, 84.0, 124.0, 84.0, 124.0 );
        that.lineTo( 35.0, 124.0 );
        that.lineTo( 18.0, 56.0 );
        that.lineTo( 202.0, 56.0 );
        that.lineTo( 202.0, 90.0 );
        that.bezierCurveTo( 202.0, 90.0, 240.0, 168.0, 209.0, 202.0 );
        that.bezierCurveTo( 175.0, 240.0, 65.0, 187.0, 65.0, 187.0 );
        that.closePath();
        that.translate( 40.0, 160.0 );
        that.moveTo( 110.0, 0.0 );
        that.lineTo( 0.0, 0.0 );
        that.lineTo( 0.0, 0.0 );
        that.bezierCurveTo( 0.0, 90.0, 110.0, 90.0, 110.0, 40.0 );
        that.closePath();
        that.fill();
        that.stroke();
        for ( let index = 0; index < 256; ++index )
        {
            let bits = index;
            bits = ( bits << 1 & 0xaa ) | ( bits >> 1 & 0x55 );
            bits = ( bits << 2 & 0xcc ) | ( bits >> 2 & 0x33 );
            bits = ( bits << 4 & 0xf0 ) | ( bits >> 4 & 0x0f );
            const x = bits / 256.0 * width;
            const y = index / 256.0 * height;
            that.rotate( 0.5 );
            const inside = that.isPointInPath( x, y );
            that.setTransform( 1.0, 0.0, 0.0, 1.0, 0.0, 0.0 );
            that.strokeStyle = inside ? "#00ff00" : "#ff0000";
            that.strokeRect( x - 1.5, y - 1.5, 3.0, 3.0 );
        }
    } );
</script>
</div>

<div class="test-container">
<h2>is_<wbr>point_<wbr>in_<wbr>path_<wbr>offscreen</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<canvas id="is_point_in_path_offscreen_browser" width="256" height="256"></canvas>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="is_point_in_path_offscreen_wasm" width="256" height="256"></canvas>
</div>
</div>
<script type="text/javascript">
    window.addEventListener( "load", function( event ) {
        const element = document.getElementById( "is_point_in_path_offscreen_browser" );
        const that = element.getContext( "2d" );
        const width = element.width;
        const height = element.height;
        that.fillStyle = "#0000ff";
        that.strokeStyle = "#ffffff";
        that.scale( width / 256.0, height / 256.0 );
        that.beginPath();
        that.moveTo( 321.0, -240.0 );
        that.lineTo( 369.0, -232.0 );
        that.bezierCurveTo( 369.0, -232.0, 349.0, -130.0, 375.0, -96.0 );
        that.bezierCurveTo( 389.0, -76.0, 426.0, -60.0, 442.0, -79.0 );
        that.bezierCurveTo( 454.0, -94.0, 438.0, -126.0, 422.0, -138.0 );
        that.bezierCurveTo( 379.0, -176.0, 340.0, -132.0, 340.0, -132.0 );
        that.lineTo( 291.0, -132.0 );
        that.lineTo( 274.0, -200.0 );
        that.lineTo( 458.0, -200.0 );
        that.lineTo( 458.0, -166.0 );
        that.bezierCurveTo( 458.0, -166.0, 496.0, -88.0, 465.0, -54.0 );
        that.bezierCurveTo( 431.0, -16.0, 321.0, -69.0, 321.0, -69.0 );
        that.closePath();
        that.translate( 40.0, 160.0 );
        that.moveTo( 366.0, -256.0 );
        that.lineTo( 256.0, -256.0 );
        that.lineTo( 256.0, -256.0 );
        that.bezierCurveTo( 256.0, -166.0, 366.0, -166.0, 366.0, -216.0 );
        that.closePath();
        that.fill();
        that.stroke();
        for ( let index = 0; index < 256; ++index )
        {
            let bits = index;
            bits = ( bits << 1 & 0xaa ) | ( bits >> 1 & 0x55 );
            bits = ( bits << 2 & 0xcc ) | ( bits >> 2 & 0x33 );
            bits = ( bits << 4 & 0xf0 ) | ( bits >> 4 & 0x0f );
            const x = bits / 256.0 * width;
            const y = index / 256.0 * height;
            that.rotate( 0.5 );
            const inside = that.isPointInPath( x + width, y - height );
            that.setTransform( 1.0, 0.0, 0.0, 1.0, 0.0, 0.0 );
            that.strokeStyle = inside ? "#00ff00" : "#ff0000";
            that.strokeRect( x - 1.5, y - 1.5, 3.0, 3.0 );
        }
    } );
</script>
</div>

<div class="test-container">
<h2>fill_<wbr>evenodd</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<div class="placeholder" style="width:256px;height:256px;">Extension test</div>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="fill_evenodd_wasm" width="256" height="256"></canvas>
</div>
</div>
</div>

<div class="test-container">
<h2>fill_<wbr>evenodd_<wbr>star</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<div class="placeholder" style="width:256px;height:256px;">Extension test</div>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="fill_evenodd_star_wasm" width="256" height="256"></canvas>
</div>
</div>
</div>

<div class="test-container">
<h2>clip_<wbr>evenodd</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<div class="placeholder" style="width:256px;height:256px;">Extension test</div>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="clip_evenodd_wasm" width="256" height="256"></canvas>
</div>
</div>
</div>

<div class="test-container">
<h2>is_<wbr>point_<wbr>in_<wbr>path_<wbr>evenodd</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<div class="placeholder" style="width:256px;height:256px;">Extension test</div>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="is_point_in_path_evenodd_wasm" width="256" height="256"></canvas>
</div>
</div>
</div>

<div class="test-container">
<h2>clear_<wbr>rectangle</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<canvas id="clear_rectangle_browser" width="256" height="256"></canvas>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="clear_rectangle_wasm" width="256" height="256"></canvas>
</div>
</div>
<script type="text/javascript">
    window.addEventListener( "load", function( event ) {
        const element = document.getElementById( "clear_rectangle_browser" );
        const that = element.getContext( "2d" );
        const width = element.width;
        const height = element.height;
        that.strokeStyle = "#ffffff";
        that.fillStyle = "#660d33";
        that.moveTo( 0.0, 0.0 );
        that.lineTo( width, 0.0 );
        that.lineTo( width, height );
        that.lineTo( 0.0, height );
        that.fill();
        that.rotate( 0.2 );
        that.beginPath();
        that.moveTo( 0.2 * width, 0.2 * height );
        that.lineTo( 0.8 * width, 0.2 * height );
        that.lineTo( 0.8 * width, 0.8 * height );
        that.shadowOffsetX = 5.0;
        that.shadowColor = "rgba(0,0,0,1.0)";
        that.globalCompositeOperation = "destination-atop";
        that.globalAlpha = 0.5;
        for ( let y = -1.0; y <= 1.0; y += 1.0 )
            for ( let x = -1.0; x <= 1.0; x += 1.0 )
                that.clearRect( ( 0.5 + 0.05 * x ) * width,
                                ( 0.5 + 0.05 * y ) * height,
                                x * 0.2 * width, y * 0.2 * height );
        that.globalAlpha = 1.0;
        that.globalCompositeOperation = "source-over";
        that.shadowColor = "rgba(0,0,0,0)";
        that.lineTo( 0.2 * width, 0.8 * height );
        that.closePath();
        that.stroke();
    } );
</script>
</div>

<div class="test-container">
<h2>fill_<wbr>rectangle</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<canvas id="fill_rectangle_browser" width="256" height="256"></canvas>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="fill_rectangle_wasm" width="256" height="256"></canvas>
</div>
</div>
<script type="text/javascript">
    window.addEventListener( "load", function( event ) {
        const element = document.getElementById( "fill_rectangle_browser" );
        const that = element.getContext( "2d" );
        const width = element.width;
        const height = element.height;
        that.strokeStyle = "#000000";
        that.fillStyle = "#660d33";
        that.rotate( 0.2 );
        that.moveTo( 0.2 * width, 0.2 * height );
        that.lineTo( 0.8 * width, 0.2 * height );
        that.lineTo( 0.8 * width, 0.8 * height );
        for ( let y = -1.0; y <= 1.0; y += 1.0 )
            for ( let x = -1.0; x <= 1.0; x += 1.0 )
                that.fillRect( ( 0.5 + 0.05 * x ) * width,
                               ( 0.5 + 0.05 * y ) * height,
                               x * 0.2 * width, y * 0.2 * height );
        that.lineTo( 0.2 * width, 0.8 * height );
        that.closePath();
        that.stroke();
    } );
</script>
</div>

<div class="test-container">
<h2>stroke_<wbr>rectangle</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<canvas id="stroke_rectangle_browser" width="256" height="256"></canvas>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="stroke_rectangle_wasm" width="256" height="256"></canvas>
</div>
</div>
<script type="text/javascript">
    window.addEventListener( "load", function( event ) {
        const element = document.getElementById( "stroke_rectangle_browser" );
        const that = element.getContext( "2d" );
        const width = element.width;
        const height = element.height;
        that.strokeStyle = "#000000";
        that.rotate( 0.2 );
        that.beginPath();
        that.moveTo( 0.2 * width, 0.2 * height );
        that.lineTo( 0.8 * width, 0.2 * height );
        that.lineTo( 0.8 * width, 0.8 * height );
        for ( let y = -1.0; y <= 1.0; y += 1.0 )
            for ( let x = -1.0; x <= 1.0; x += 1.0 )
                that.strokeRect( ( 0.5 + 0.05 * x ) * width,
                                 ( 0.5 + 0.05 * y ) * height,
                                 x * 0.2 * width, y * 0.2 * height );
        that.lineTo( 0.2 * width, 0.8 * height );
        that.closePath();
        that.stroke();
    } );
</script>
</div>

<div class="test-container">
<h2>text_<wbr>align</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<canvas id="text_align_browser" width="256" height="256"></canvas>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="text_align_wasm" width="256" height="256"></canvas>
</div>
</div>
<script type="text/javascript">
    window.addEventListener( "load", function( event ) {
        const element = document.getElementById( "text_align_browser" );
        const that = element.getContext( "2d" );
        const width = element.width;
        const height = element.height;
        that.font = ( 0.2 * height ) + "px FontA";
        that.rotate( 0.2 );
        that.fillStyle = "#000000";
        const alignments = [ "left", "center", "right", "start", "end" ];
        for ( let index = 0; index < 5; ++index )
        {
            const base = ( 0.1 + 0.2 * index ) * height;
            that.textAlign = alignments[ index ];
            that.fillText( "HIty", 0.5 * width, base );
        }
        that.strokeStyle = "rgba(255,0,0,0.5)";
        that.lineWidth = 1.0;
        that.moveTo( 0.0, 0.5 * height );
        that.lineTo( width, 0.5 * height );
        that.moveTo( 0.5 * width, 0.0 );
        that.lineTo( 0.5 * width, height );
        that.stroke();
    } );
</script>
</div>

<div class="test-container">
<h2>text_<wbr>baseline</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<canvas id="text_baseline_browser" width="256" height="256"></canvas>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="text_baseline_wasm" width="256" height="256"></canvas>
</div>
</div>
<script type="text/javascript">
    window.addEventListener( "load", function( event ) {
        const element = document.getElementById( "text_baseline_browser" );
        const that = element.getContext( "2d" );
        const width = element.width;
        const height = element.height;
        that.font = ( 0.2 * height ) + "px FontA";
        that.rotate( 0.2 );
        that.fillStyle = "#000000";
        const baselines = [
            "alphabetic", "top", "middle", "bottom", "hanging", "ideographic" ];
        for ( let index = 0; index < 6; ++index )
        {
            const left = ( 0.1 + 0.15 * index ) * width;
            that.textBaseline = baselines[ index ];
            that.fillText( "Iy", left, 0.5 * height );
        }
        that.strokeStyle = "rgba(255,0,0,0.5)";
        that.lineWidth = 1.0;
        that.moveTo( 0.0, 0.5 * height );
        that.lineTo( width, 0.5 * height );
        that.moveTo( 0.5 * width, 0.0 );
        that.lineTo( 0.5 * width, height );
        that.stroke();
    } );
</script>
</div>

<div class="test-container">
<h2>font</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<canvas id="font_browser" width="256" height="256"></canvas>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="font_wasm" width="256" height="256"></canvas>
</div>
</div>
<script type="text/javascript">
    window.addEventListener( "load", function( event ) {
        const element = document.getElementById( "font_browser" );
        const that = element.getContext( "2d" );
        const width = element.width;
        const height = element.height;
        const text = new TextDecoder().decode( new Uint8Array( [
            0x43, 0x45, 0xc3, 0x8d, 0xf4, 0x8f, 0xbf, 0xbd, 0xf0, 0x49 ] ) );
        that.strokeStyle = "#FF0000";
        that.strokeText( "D", 0.8 * width, 0.95 * height );
        that.fillStyle = "#FF0000";
        that.fillText( "D", 0.9 * width, 0.95 * height );
        that.font = ( 0.1 * height ) + "px";
        that.fillStyle = "#000000";
        that.font = ( 0.2 * height ) + "px FontA";
        that.fillText( text, 0.0, 0.20 * height );
        that.font = ( 0.1 * height ) + "px FontA";
        that.fillText( text, 0.65 * width, 0.20 * height );
        that.font = ( 0.2 * height ) + "px FontB";
        that.fillText( text, 0.0, 0.45 * height );
        that.font = ( 0.2 * height ) + "px FontC";
        that.fillText( text, 0.0, 0.70 * height );
        that.fillStyle = "#FF0000";
        that.font = ( 0.2 * height ) + "px FontD";
        that.fillText( "D", 0.1 * width, 0.95 * height );
        that.font = ( 0.2 * height ) + "px FontE";
        that.fillText( "D", 0.2 * width, 0.95 * height );
        that.font = ( 0.2 * height ) + "px FontF";
        that.fillText( "D", 0.3 * width, 0.95 * height );
        that.font = ( 0.2 * height ) + "px FontG";
        that.fillText( "D", 0.4 * width, 0.95 * height );
    } );
</script>
</div>

<div class="test-container">
<h2>fill_<wbr>text</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<canvas id="fill_text_browser" width="256" height="256"></canvas>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="fill_text_wasm" width="256" height="256"></canvas>
</div>
</div>
<script type="text/javascript">
    window.addEventListener( "load", function( event ) {
        const element = document.getElementById( "fill_text_browser" );
        const that = element.getContext( "2d" );
        const width = element.width;
        const height = element.height;
        const gradient = that.createLinearGradient( 0.4 * width, 0.0, 0.6 * width, 0.0 );
        gradient.addColorStop( 0.00, "#0000ff" );
        gradient.addColorStop( 0.45, "#004080" );
        gradient.addColorStop( 0.50, "#ff0000" );
        gradient.addColorStop( 0.55, "#004080" );
        gradient.addColorStop( 1.00, "#008000" );
        that.fillStyle = gradient;
        that.font = ( 0.3 * height ) + "px FontA";
        that.rotate( 0.2 );
        that.shadowOffsetX = 2.0;
        that.shadowOffsetY = 2.0;
        that.shadowBlur = 4.0;
        that.shadowColor = "rgba(0,0,0,0.75)";
        that.moveTo( 0.0, 0.2 * height );
        that.fillText( "Canvas", 0.1 * width, 0.2 * height );
        that.lineTo( width, 0.2 * height );
        that.fillText( "Ity\n*", 0.2 * width, 0.5 * height, width );
        that.moveTo( 0.0, 0.5 * height );
        that.fillText( "*Canvas\fIty*", 0.2 * width, 0.8 * height, 0.7 * width );
        that.fillStyle = "#ff0000";
        that.fillText( "****", 0.1 * width, 0.35 * height, 0.0 );
        that.lineTo( width, 0.5 * height );
        that.shadowColor = "rgba(0,0,0,0)";
        that.strokeStyle = "#ff0000";
        that.lineWidth = 2.0;
        that.stroke();
    } );
</script>
</div>

<div class="test-container">
<h2>stroke_<wbr>text</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<canvas id="stroke_text_browser" width="256" height="256"></canvas>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="stroke_text_wasm" width="256" height="256"></canvas>
</div>
</div>
<script type="text/javascript">
    window.addEventListener( "load", function( event ) {
        const element = document.getElementById( "stroke_text_browser" );
        const that = element.getContext( "2d" );
        const width = element.width;
        const height = element.height;
        that.strokeStyle = "#000000";
        that.font = ( 0.3 * height ) + "px FontA";
        that.rotate( 0.2 );
        that.lineWidth = 2.0;
        that.setLineDash( [ 8.0, 2.0 ] );
        that.moveTo( 0.0, 0.2 * height );
        that.strokeText( "Canvas", 0.1 * width, 0.2 * height );
        that.lineTo( width, 0.2 * height );
        that.strokeText( "Ity\n*", 0.2 * width, 0.5 * height, width );
        that.moveTo( 0.0, 0.5 * height );
        that.strokeText( "*Canvas\fIty*", 0.2 * width, 0.8 * height, 0.7 * width );
        that.strokeStyle = "#ff0000";
        that.strokeText( "****", 0.1 * width, 0.35 * height, 0.0 );
        that.lineTo( width, 0.5 * height );
        that.setLineDash( [] );
        that.stroke();
    } );
</script>
</div>

<div class="test-container">
<h2>measure_<wbr>text</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<canvas id="measure_text_browser" width="256" height="256"></canvas>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="measure_text_wasm" width="256" height="256"></canvas>
</div>
</div>
<script type="text/javascript">
    window.addEventListener( "load", function( event ) {
        const element = document.getElementById( "measure_text_browser" );
        const that = element.getContext( "2d" );
        const width = element.width;
        const height = element.height;
        that.fillStyle = "#000000";
        let place = 0.1 * width;
        // place += that.measureText( "C" ).width;
        that.font = ( 0.3 * height ) + "px FontA";
        that.rotate( 0.5 );
        that.scale( 1.15, 1.0 );
        that.fillText( "C", place, 0.2 * height );
        place += that.measureText( "C" ).width;
        that.fillText( "a", place, 0.25 * height );
        place += that.measureText( "a" ).width;
        that.fillText( "nv", place, 0.2 * height );
        place += that.measureText( "nv" ).width;
        that.fillText( "a", place, 0.15 * height );
        place += that.measureText( "a" ).width;
        that.fillText( "s", place, 0.2 * height );
    } );
</script>
</div>

<div class="test-container">
<h2>text_<wbr>kerning</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<div class="placeholder" style="width:256px;height:256px;">C-only test</div>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="text_kerning_wasm" width="256" height="256"></canvas>
</div>
</div>
</div>

<div class="test-container">
<h2>text_<wbr>kerning_<wbr>measure</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<div class="placeholder" style="width:256px;height:256px;">C-only test</div>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="text_kerning_measure_wasm" width="256" height="256"></canvas>
</div>
</div>
</div>

<div class="test-container">
<h2>text_<wbr>kerning_<wbr>aat</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<div class="placeholder" style="width:256px;height:256px;">C-only test</div>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="text_kerning_aat_wasm" width="256" height="256"></canvas>
</div>
</div>
</div>

<div class="test-container">
<h2>text_<wbr>kerning_<wbr>aat_<wbr>measure</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<div class="placeholder" style="width:256px;height:256px;">C-only test</div>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="text_kerning_aat_measure_wasm" width="256" height="256"></canvas>
</div>
</div>
</div>

<div class="test-container">
<h2>text_<wbr>kerning_<wbr>gpos_<wbr>fmt1</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<div class="placeholder" style="width:256px;height:256px;">C-only test</div>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="text_kerning_gpos_fmt1_wasm" width="256" height="256"></canvas>
</div>
</div>
</div>

<div class="test-container">
<h2>text_<wbr>kerning_<wbr>gpos_<wbr>fmt2</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<div class="placeholder" style="width:256px;height:256px;">C-only test</div>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="text_kerning_gpos_fmt2_wasm" width="256" height="256"></canvas>
</div>
</div>
</div>

<div class="test-container">
<h2>draw_<wbr>image</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<canvas id="draw_image_browser" width="256" height="256"></canvas>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="draw_image_wasm" width="256" height="256"></canvas>
</div>
</div>
<script type="text/javascript">
    window.addEventListener( "load", function( event ) {
        const element = document.getElementById( "draw_image_browser" );
        const that = element.getContext( "2d" );
        const width = element.width;
        const height = element.height;
        const checker = new Uint8ClampedArray( 1024 );
        for ( let index = 0; index < 1024; ++index )
            checker[ index ] =
                ( ( ( index >> 2 & 1 ) ^ ( index >> 6 & 1 ) ) |
                  ( ( index & 3 ) == 3 ) ) * 255;
        const image = document.createElement( "canvas" );
        image.width = 16;
        image.height = 16;
        image.getContext( "2d" ).putImageData(
            new ImageData( checker, 16, 16 ), 0, 0 );
        that.drawImage( image, 0.0, 0.0, width * 0.75, height * 0.75 );
        for ( let row = 0.0; row < 4.0; row += 1.0 )
            for ( let column = 0.0; column < 4.0; column += 1.0 )
                that.drawImage( image,
                                column * 17.25, row * 17.25, 16.0, 16.0 );
        that.drawImage( image, 128.0, 0.0, 32.0, 8.0 );
        that.drawImage( image, 128.0, 48.0, 32.0, -32.0 );
        that.drawImage( image, 200.0, 16.0, -32.0, 32.0 );
        that.drawImage( image, 128.0, 64.0, 32.0, 0.0 );
        try {
            that.drawImage( null, 200.0, 64.0, 32.0, 32.0 );
        } catch ( error ) {}
        const pixel = new Uint8ClampedArray( [ 0, 255, 0, 255 ] );
        const image2 = document.createElement( "canvas" );
        image2.width = 1;
        image2.height = 1;
        image2.getContext( "2d" ).putImageData(
            new ImageData( pixel, 1, 1 ), 0, 0 );
        that.drawImage( image2, width * 0.875, height * 0.25, 1.0, 1.0 );
        that.drawImage( image2, width * 0.875, height * 0.5, 16.0, 16.0 );
        that.rotate( 0.2 );
        that.globalCompositeOperation = "lighter";
        that.globalAlpha = 1.0;
        that.drawImage( image,
                        0.25 * width, 0.25 * height,
                        0.5 * width, 0.5 * height );
    } );
</script>
</div>

<div class="test-container">
<h2>draw_<wbr>image_<wbr>matted</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<canvas id="draw_image_matted_browser" width="256" height="256"></canvas>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="draw_image_matted_wasm" width="256" height="256"></canvas>
</div>
</div>
<script type="text/javascript">
    window.addEventListener( "load", function( event ) {
        const element = document.getElementById( "draw_image_matted_browser" );
        const that = element.getContext( "2d" );
        const width = element.width;
        const height = element.height;
        that.fillStyle = "rgba(0,255,0,0.0)";
        that.fillRect( 0.0, 0.0, width, height );
        const checker = new Uint8ClampedArray( [
            0, 0, 255, 255,  255, 0, 0, 0,    0, 0, 255, 255,
            255, 0, 0, 0,    0, 0, 255, 255,  255, 0, 0, 0,
            0, 0, 255, 255,  255, 0, 0, 0,    0, 0, 255, 255,
        ] );
        const image = document.createElement( "canvas" );
        image.width = 3;
        image.height = 3;
        image.getContext( "2d" ).putImageData(
            new ImageData( checker, 3, 3 ), 0, 0 );
        let y = 0.5;
        let size_y = 3.0;
        for ( let step_y = 0; step_y < 20 && y < height; ++step_y )
        {
            let x = 0.5;
            let size_x = 3.0;
            for ( let step_x = 0; step_x < 20 && x < width; ++step_x )
            {
                that.drawImage( image, x, y, size_x, size_y );
                x += size_x + 5.0;
                size_x *= 1.5;
            }
            y += size_y + 5.0;
            size_y *= 1.5;
        }
    } );
</script>
</div>

<div class="test-container">
<h2>get_<wbr>image_<wbr>data</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<canvas id="get_image_data_browser" width="256" height="256"></canvas>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="get_image_data_wasm" width="256" height="256"></canvas>
</div>
</div>
<script type="text/javascript">
    window.addEventListener( "load", function( event ) {
        const element = document.getElementById( "get_image_data_browser" );
        const that = element.getContext( "2d" );
        const width = element.width;
        const height = element.height;
        for ( let index = 0; index < 100; ++index )
        {
            that.fillStyle = "rgba(" +
                ( index >> 1 ) % 2 * 255 + "," +
                ( index >> 2 ) % 2 * 255 + "," +
                ( index >> 3 ) % 2 * 255 + "," +
                ( index >> 4 ) % 2 * 1.0 + ")";
            that.fillRect( 3.0 * ( index % 10 ),
                           3.0 * Math.trunc( index / 10 ),
                           3.0, 3.0 );
        }
        const data = new Uint8ClampedArray( 4939 );
        data[ 0 ] = 150;
        for ( let index = 1; index < 4939; ++index )
            data[ index ] = ( data[ index - 1 ] * 137 + 53 ) & 255;
        const image = that.getImageData( -10, -10, 35, 35 );
        for ( let y = 0; y < 35; ++y )
            for ( let x = 0; x < 35 * 4; ++x )
                data[ 2 + y * 141 + x ] = image.data[ y * 35 * 4 + x ];
        let hash = 0;
        for ( let index = 0; index < 4939; ++index )
        {
            hash = ( ( ( hash & 0x1ffff ) << 15 ) | ( hash >>> 17 ) ) ^ data[ index ];
            hash = hash & 0xffffffff;
        }
        const expected = 0xf53f9792 | 0;
        that.fillStyle = hash == expected ? "#00ff00" : "#ff0000";
        that.fillRect( 30.0, 0.0, width, 30.0 );
        const gradient = that.createLinearGradient( 0.0, 0.0, width, 0.0 );
        gradient.addColorStop( 0.0, "#ff0000" );
        gradient.addColorStop( 1.0, "#00ff00" );
        that.fillStyle = gradient;
        that.fillRect( 0.0, 0.45 * height, width, 0.1 * height );
    } );
</script>
</div>

<div class="test-container">
<h2>put_<wbr>image_<wbr>data</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<canvas id="put_image_data_browser" width="256" height="256"></canvas>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="put_image_data_wasm" width="256" height="256"></canvas>
</div>
</div>
<script type="text/javascript">
    window.addEventListener( "load", function( event ) {
        const element = document.getElementById( "put_image_data_browser" );
        const that = element.getContext( "2d" );
        const width = element.width;
        const height = element.height;
        const checker = new Uint8ClampedArray( 2052 );
        for ( let index = 0; index < 2048; ++index )
            checker[ index + 2 ] =
                ( ( ( ( index >> 2 & 1 ) ^ ( index >> 7 & 1 ) ) |
                    ( ( index & 3 ) == 3 ) ) &
                  ( index >> 10 & 1 ) ) * 255;
        checker[ 0 ] = 157;
        checker[ 1 ] = 157;
        checker[ 2050 ] = 157;
        checker[ 2051 ] = 157;
        const image = that.createImageData( 16, 16 );
        for ( let y = 0; y < 16; ++y )
            for ( let x = 0; x < 16 * 4; ++x )
                image.data[ y * 16 * 4 + x ] = checker[ 6 + y * 128 + x ];
        that.fillStyle = "#660d33";
        that.fillRect( 0, 0, 0.25 * width, 0.25 * height );
        that.globalAlpha = 0.5;
        that.globalCompositeOperation = "lighter";
        that.rotate( 0.2 );
        for ( let y = -10; y < height; y += 29 )
            for ( let x = -10; x < width; x += 29 )
                that.putImageData( image, x, y );
        try {
            that.putImageData( null, 0, 0 );
        } catch ( error ) {}
    } );
</script>
</div>

<div class="test-container">
<h2>save_<wbr>restore</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<canvas id="save_restore_browser" width="256" height="256"></canvas>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="save_restore_wasm" width="256" height="256"></canvas>
</div>
</div>
<script type="text/javascript">
    window.addEventListener( "load", function( event ) {
        const element = document.getElementById( "save_restore_browser" );
        const that = element.getContext( "2d" );
        const width = element.width;
        const height = element.height;
        that.rect( width * 0.25, height * 0.25,
                   width * 0.25, height * 0.25 );
        that.strokeStyle = "#0000ff";
        that.lineWidth = 8.0;
        that.save();
        that.clip();
        that.beginPath();
        that.rect( width * 0.25, height * 0.25,
                   width * 0.5, height * 0.5 );
        that.strokeStyle = "#ff0000";
        that.lineWidth = 1.0;
        that.restore();
        that.restore();
        that.stroke();
        that.save();
        that.save();
    } );
</script>
</div>

<div class="test-container">
<h2>example_<wbr>button</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<canvas id="example_button_browser" width="256" height="256"></canvas>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="example_button_wasm" width="256" height="256"></canvas>
</div>
</div>
<script type="text/javascript">
    window.addEventListener( "load", function( event ) {
        const element = document.getElementById( "example_button_browser" );
        const that = element.getContext( "2d" );
        const width = element.width;
        const height = element.height;
        const left = Math.round( 0.25 * width );
        const right = Math.round( 0.75 * width );
        const top = Math.round( 0.375 * height );
        const bottom = Math.round( 0.625 * height );
        const midX = ( left + right ) * 0.5;
        const midY = ( top + bottom ) * 0.5;
        that.shadowOffsetX = 3.0;
        that.shadowOffsetY = 3.0;
        that.shadowBlur = 3.0;
        that.shadowColor = "rgba(0,0,0,0.5)";
        const gradient = that.createLinearGradient( 0.0, top, 0.0, bottom );
        gradient.addColorStop( 0.0, "#4c4c4c" );
        gradient.addColorStop( 1.0, "#333333" );
        that.fillStyle = gradient;
        that.moveTo( left + 0.5, midY );
        that.arcTo( left + 0.5, top + 0.5, midX, top + 0.5, 4.0 );
        that.arcTo( right - 0.5, top + 0.5, right - 0.5, midY, 4.0 );
        that.arcTo( right - 0.5, bottom - 0.5, midX, bottom - 0.5, 4.0 );
        that.arcTo( left + 0.5, bottom - 0.5, left + 0.5, midY, 4.0 );
        that.closePath();
        that.fill();
        that.shadowColor = "rgba(0,0,0,0)";
        that.font = ( 0.075 * height ) + "px FontA";
        that.textAlign = "center";
        that.textBaseline = "middle";
        that.fillStyle = "#cccccc";
        that.fillText( "* Cats", 0.5 * width, 0.5 * height );
        that.fillStyle = "#666666";
        that.fillRect( left + 4.0, top + 1.0, right - left - 8.0, 1.0 );
        that.strokeStyle = "#1a1a1a";
        that.stroke();
    } );
</script>
</div>

<div class="test-container">
<h2>example_<wbr>smiley</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<canvas id="example_smiley_browser" width="256" height="256"></canvas>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="example_smiley_wasm" width="256" height="256"></canvas>
</div>
</div>
<script type="text/javascript">
    window.addEventListener( "load", function( event ) {
        const element = document.getElementById( "example_smiley_browser" );
        const that = element.getContext( "2d" );
        const width = element.width;
        const height = element.height;
        const centerX = 0.5 * width;
        const centerY = 0.5 * height;
        const radius = Math.min( width, height ) * 0.4;
        let gradient = that.createRadialGradient( centerX, centerY, 0.0,
                                                  centerX, centerY, radius );
        gradient.addColorStop( 0.0, "#ffe633" );
        gradient.addColorStop( 0.95, "#f2a626" );
        gradient.addColorStop( 1.0, "#e68c00" );
        that.fillStyle = gradient;
        that.arc( centerX, centerY, radius, 0.0, 6.28318531 );
        that.fill();
        gradient = that.createLinearGradient( centerX, centerY - 0.95 * radius,
                                              centerX, centerY );
        gradient.addColorStop( 0.0, "rgba(255,255,255,0.5)" );
        gradient.addColorStop( 1.0, "rgba(255,255,255,0)" );
        that.fillStyle = gradient;
        that.beginPath();
        that.arc( centerX, centerY - 0.15 * radius, 0.8 * radius,
                  0.0, 6.28318531 );
        that.fill();
        that.strokeColor = "rgba(0,0,0,0.95)";
        that.lineWidth = 0.2 * radius;
        that.lineCap = "round";
        that.beginPath();
        that.moveTo( centerX - 0.2 * radius, centerY - 0.5 * radius );
        that.lineTo( centerX - 0.2 * radius, centerY - 0.2 * radius );
        that.moveTo( centerX + 0.2 * radius, centerY - 0.5 * radius );
        that.lineTo( centerX + 0.2 * radius, centerY - 0.2 * radius );
        that.stroke();
        that.fillStyle = "rgba(0,0,0,0.95)";
        that.beginPath();
        that.moveTo( centerX - 0.6 * radius, centerY + 0.1 * radius );
        that.bezierCurveTo( centerX - 0.3 * radius, centerY + 0.8 * radius,
                            centerX + 0.3 * radius, centerY + 0.8 * radius,
                            centerX + 0.6 * radius, centerY + 0.1 * radius);
        that.bezierCurveTo( centerX + 0.3 * radius, centerY + 0.3 * radius,
                            centerX - 0.3 * radius, centerY + 0.3 * radius,
                            centerX - 0.6 * radius, centerY + 0.1 * radius);
        that.fill();
    } );
</script>
</div>

<div class="test-container">
<h2>example_<wbr>knot</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<canvas id="example_knot_browser" width="256" height="256"></canvas>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="example_knot_wasm" width="256" height="256"></canvas>
</div>
</div>
<script type="text/javascript">
    window.addEventListener( "load", function( event ) {
        const element = document.getElementById( "example_knot_browser" );
        const that = element.getContext( "2d" );
        const width = element.width;
        const height = element.height;
        const points = [
            [  0.0, -1.0,  0.0,  0.0,  0.0,  0.0,  0.0,  1.0 ],
            [ -1.0, -1.0, -1.0,  0.0,  1.0,  0.0,  1.0,  1.0 ],
            [  2.0,  1.0,  2.0, -2.0, -1.0, -2.0, -1.0, -1.0 ],
            [ -2.0, -1.0, -2.0,  2.0,  1.0,  2.0,  1.0,  1.0 ],
            [ -2.0, -1.0, -2.0, -3.0,  0.0, -3.0,  0.0, -1.0 ],
            [  2.0,  1.0,  2.0,  3.0,  0.0,  3.0,  0.0,  1.0 ],
        ];
        that.translate( width * 0.5, height * 0.5 );
        that.scale( width * 0.17, height * 0.17 );
        that.rotate( -15.0 * 3.14159265 / 180.0 );
        for ( let index = 0; index < 6; ++index )
        {
            that.beginPath();
            that.moveTo(
                1.01 * points[ index ][ 0 ] - 0.01 * points[ index ][ 2 ],
                1.01 * points[ index ][ 1 ] - 0.01 * points[ index ][ 3 ] );
            that.lineTo( points[ index ][ 0 ], points[ index ][ 1 ] );
            that.bezierCurveTo( points[ index ][ 2 ], points[ index ][ 3 ],
                                points[ index ][ 4 ], points[ index ][ 5 ],
                                points[ index ][ 6 ], points[ index ][ 7 ] );
            that.lineTo(
                -0.01 * points[ index ][ 4 ] + 1.01 * points[ index ][ 6 ],
                -0.01 * points[ index ][ 5 ] + 1.01 * points[ index ][ 7 ] );
            that.strokeStyle = "#000000";
            that.lineWidth = 0.75;
            that.lineCap = "butt";
            that.stroke();
            const gradient = that.createRadialGradient( 0.0, 0.0, 0.0,
                                                      0.0, 0.0, 3.0 );
            gradient.addColorStop( 0.0, "#ccff99" );
            gradient.addColorStop( 1.0, "#1a8020" );
            that.strokeStyle = gradient;
            that.lineWidth = 0.5;
            that.lineCap = "round";
            that.stroke();
        }
    } );
</script>
</div>

<div class="test-container">
<h2>example_<wbr>icon</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<canvas id="example_icon_browser" width="256" height="256"></canvas>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="example_icon_wasm" width="256" height="256"></canvas>
</div>
</div>
<script type="text/javascript">
    window.addEventListener( "load", function( event ) {
        const element = document.getElementById( "example_icon_browser" );
        const that = element.getContext( "2d" );
        const width = element.width;
        const height = element.height;
        that.shadowColor = "#000000";
        that.shadowOffsetX = width / 64.0;
        that.shadowOffsetY = height / 64.0;
        that.shadowBlur = Math.min( width, height ) / 32.0;
        that.scale( width / 32.0, height / 32.0 );
        that.fillStyle = "#660d33";
        that.moveTo( 15.5, 1.0 );
        that.arcTo( 30.0, 1.0, 30.0, 15.5, 6.0 );
        that.arcTo( 30.0, 30.0, 15.5, 30.0, 6.0 );
        that.arcTo( 1.0, 30.0, 1.0, 15.5, 6.0 );
        that.arcTo( 1.0, 1.0, 15.5, 1.0, 6.0 );
        that.fill();
        that.strokeStyle = "#808080";
        that.beginPath();
        that.moveTo( 11.0, 16.0 );
        that.lineTo( 27.0, 16.0 );
        that.moveTo( 2.0, 23.0 );
        that.lineTo( 29.0, 23.0 );
        that.stroke();
        that.strokeStyle = "#c0c0c0";
        that.beginPath();
        that.arc( 25.0, 22.0, 0.5, 0.0, 6.28318531 );
        that.moveTo( 19.0, 6.0 );
        that.lineTo( 18.5, 8.0 );
        that.moveTo( 20.0, 6.0 );
        that.lineTo( 20.0, 8.0 );
        that.moveTo( 21.0, 6.0 );
        that.lineTo( 21.5, 8.0 );
        that.moveTo( 17.0, 14.0 );
        that.lineTo( 16.0, 18.0 );
        that.moveTo( 20.0, 14.0 );
        that.lineTo( 20.0, 18.0 );
        that.moveTo( 23.0, 14.0 );
        that.lineTo( 24.0, 18.0 );
        that.moveTo( 18.0, 9.0 );
        that.lineTo( 22.0, 9.0 );
        that.moveTo( 18.0, 13.0 );
        that.lineTo( 22.0, 13.0 );
        that.rect( 16.0, 8.0, 8.0, 6.0 );
        that.stroke();
        that.strokeStyle = "#ffffff";
        that.beginPath();
        that.arc( 19.0, 12.0, 9.0, 0.0, 6.28318531 );
        that.moveTo( 12.3, 17.3 );
        that.lineTo( 3.3, 26.3 );
        that.moveTo( 13.0, 18.0 );
        that.lineTo( 4.0, 27.0 );
        that.moveTo( 13.7, 18.7 );
        that.lineTo( 4.7, 27.7 );
        that.stroke();
    } );
</script>
</div>

<div class="test-container">
<h2>example_<wbr>illusion</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<canvas id="example_illusion_browser" width="256" height="256"></canvas>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="example_illusion_wasm" width="256" height="256"></canvas>
</div>
</div>
<script type="text/javascript">
    window.addEventListener( "load", function( event ) {
        const element = document.getElementById( "example_illusion_browser" );
        const that = element.getContext( "2d" );
        const width = element.width;
        const height = element.height;
        that.fillStyle = "#0066ff";
        that.fillRect( 0, 0, width, height );
        that.fillStyle = "#cccc00";
        that.lineWidth = 0.4;
        for ( let spot = 0.0; spot < 240.0; spot += 1.0 )
        {
            const angle = ( ( spot * 0.61803398875 ) % 1.0 ) * 6.28318531;
            const radius = spot / 240.0 * 0.5 * Math.hypot( width, height );
            const size = Math.min( width, height ) * Math.sqrt( spot ) / 240.0;
            that.setTransform( 1.0, 0.0, 0.0, 1.0, 0.0, 0.0 );
            that.translate( 0.5 * width + radius * Math.cos( angle ),
                            0.5 * height + radius * Math.sin( angle ) );
            that.rotate( angle - 1.3 );
            that.scale( 0.8 * size, 0.6 * size );
            that.rotate( 1.3 );
            that.beginPath();
            that.arc( 0.0, 0.0, 1.0, 0.0, 6.28318531 );
            that.fill();
            that.beginPath();
            that.arc( 0.0, 0.0, 1.0, 0.0, 3.14159265 );
            that.strokeStyle = "#ffffff";
            that.stroke();
            that.beginPath();
            that.arc( 0.0, 0.0, 1.0, 3.14159265, 6.28318531 );
            that.strokeStyle = "#000000";
            that.stroke();
        }
    } );
</script>
</div>

<div class="test-container">
<h2>example_<wbr>star</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<canvas id="example_star_browser" width="256" height="256"></canvas>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="example_star_wasm" width="256" height="256"></canvas>
</div>
</div>
<script type="text/javascript">
    window.addEventListener( "load", function( event ) {
        const element = document.getElementById( "example_star_browser" );
        const that = element.getContext( "2d" );
        const width = element.width;
        const height = element.height;
        that.scale( width / 256.0, height / 256.0 );
        that.moveTo( 128.0, 28.0 );
        that.lineTo( 157.0, 87.0 );
        that.lineTo( 223.0, 97.0 );
        that.lineTo( 175.0, 143.0 );
        that.lineTo( 186.0, 208.0 );
        that.lineTo( 128.0, 178.0 );
        that.lineTo( 69.0, 208.0 );
        that.lineTo( 80.0, 143.0 );
        that.lineTo( 32.0, 97.0 );
        that.lineTo( 98.0, 87.0 );
        that.closePath();
        that.shadowBlur = 8.0;
        that.shadowOffsetY = 4.0;
        that.shadowColor = "rgba(0,0,0,0.5)";
        that.fillStyle = "#ffe633";
        that.fill();
        that.lineJoin = "round";
        that.lineWidth = 12.0;
        that.strokeStyle = "#e60080";
        that.stroke();
        that.setLineDash( [ 21.0, 9.0, 1.0, 9.0, 7.0, 9.0, 1.0, 9.0 ] );
        that.lineDashOffset = 10.0;
        that.lineCap = "round";
        that.lineWidth = 6.0;
        that.strokeStyle = "#f2a626";
        that.stroke();
        that.shadowColor = "rgba(0,0,0,0.0)";
        let gradient = that.createLinearGradient( 64.0, 0.0, 192.0, 256.0 );
        gradient.addColorStop( 0.30, "rgba(255,255,255,0.0)" );
        gradient.addColorStop( 0.35, "rgba(255,255,255,0.8)" );
        gradient.addColorStop( 0.45, "rgba(255,255,255,0.8)" );
        gradient.addColorStop( 0.50, "rgba(255,255,255,0.0)" );
        that.fillStyle = gradient;
        that.globalCompositeOperation = "source-atop";
        that.fillRect( 0.0, 0.0, 256.0, 256.0 );
    } );
</script>
</div>

<div class="test-container">
<h2>example_<wbr>neon</h2>
<div class="panels">
<div class="panel">
<div class="panel-label">BROWSER</div>
<canvas id="example_neon_browser" width="256" height="256"></canvas>
</div>
<div class="panel">
<div class="panel-label">WASM</div>
<canvas id="example_neon_wasm" width="256" height="256"></canvas>
</div>
</div>
<script type="text/javascript">
    window.addEventListener( "load", function( event ) {
        const element = document.getElementById( "example_neon_browser" );
        const that = element.getContext( "2d" );
        const width = element.width;
        const height = element.height;
        that.scale( width / 256.0, height / 256.0 );
        that.fillStyle = "#001020";
        that.fillRect( 0.0, 0.0, 256.0, 256.0 );
        that.moveTo( 45.5, 96.2 );
        that.bezierCurveTo( 45.5, 96.2, 31.3, 106.2, 31.5, 113.1 );
        that.bezierCurveTo( 31.7, 119.5, 50.6, 104.8, 50.6, 93.9 );
        that.bezierCurveTo( 50.6, 91.1, 46.6, 89.1, 43.3, 89.4 );
        that.bezierCurveTo( 27.5, 90.6, 8.5, 108.2, 8.8, 121.8 );
        that.bezierCurveTo( 9.1, 133.1, 21.3, 136.6, 29.8, 136.3 );
        that.bezierCurveTo( 52.4, 135.5, 62.3, 115.6, 62.3, 115.6 );
        that.moveTo( 81.0, 120.2 );
        that.bezierCurveTo( 81.0, 120.2, 60.2, 123.0, 59.7, 130.8 );
        that.bezierCurveTo( 59.2, 140.6, 73.8, 136.4, 78.3, 125.3 );
        that.moveTo( 80.7, 130.5 );
        that.bezierCurveTo( 79.5, 132.4, 80.9, 135.0, 83.4, 135.0 );
        that.bezierCurveTo( 95.8, 135.6, 99.3, 122.5, 111.4, 121.6 );
        that.bezierCurveTo( 112.8, 121.5, 114.0, 123.0, 114.0, 124.3 );
        that.bezierCurveTo( 113.9, 126.1, 106.7, 133.9, 106.7, 133.9 );
        that.moveTo( 118.5, 122.9 );
        that.bezierCurveTo( 118.5, 122.9, 122.1, 118.8, 126.1, 122.0 );
        that.bezierCurveTo( 131.4, 126.4, 118.7, 131.6, 124.3, 134.7 );
        that.bezierCurveTo( 130.0, 137.8, 150.0, 116.5, 156.0, 120.2 );
        that.bezierCurveTo( 160.2, 122.8, 149.0, 133.5, 155.6, 133.6 );
        that.bezierCurveTo( 162.0, 133.4, 173.8, 118.3, 168.0, 117.8 );
        that.moveTo( 173.1, 123.2 );
        that.bezierCurveTo( 177.8, 124.8, 182.8, 123.2, 187.0, 119.7 );
        that.moveTo( 206.1, 118.6 );
        that.bezierCurveTo( 206.1, 118.6, 185.3, 121.3, 185.1, 129.1 );
        that.bezierCurveTo( 185.0, 138.7, 199.9, 135.4, 203.6, 123.6 );
        that.moveTo( 205.6, 129.9 );
        that.bezierCurveTo( 204.4, 131.8, 205.8, 134.4, 208.3, 134.4 );
        that.bezierCurveTo( 220.3, 134.4, 246.6, 117.1, 246.6, 117.1 );
        that.moveTo( 247.0, 122.4 );
        that.bezierCurveTo( 245.9, 128.5, 243.9, 139.7, 231.2, 131.5 );
        that.lineCap = "round";
        that.shadowColor = "#ff8000";
        that.shadowBlur = 20.0;
        that.lineWidth = 4.0;
        that.strokeStyle = "#ff8000";
        that.stroke();
        that.shadowBlur = 5.0;
        that.lineWidth = 3.0;
        that.strokeStyle = "#ffa000";
        that.stroke();
    } );
</script>
</div>


<script type="text/javascript">
// =========================================================================
// WASM glue code
// =========================================================================

// CI enum constants (must match canvas_ity.h exactly)
const CI_FILL_STYLE = 0;
const CI_STROKE_STYLE = 1;

const CI_CAP_BUTT = 0;
const CI_CAP_SQUARE = 1;
const CI_CAP_CIRCLE = 2;

const CI_JOIN_MITER = 0;
const CI_JOIN_BEVEL = 1;
const CI_JOIN_ROUNDED = 2;

const CI_REPEAT = 0;
const CI_REPEAT_X = 1;
const CI_REPEAT_Y = 2;
const CI_NO_REPEAT = 3;

const CI_SOURCE_IN = 1;
const CI_SOURCE_COPY = 2;
const CI_SOURCE_OUT = 3;
const CI_DESTINATION_IN = 4;
const CI_DESTINATION_ATOP = 7;
const CI_LIGHTER = 10;
const CI_DESTINATION_OVER = 11;
const CI_DESTINATION_OUT = 12;
const CI_SOURCE_ATOP = 13;
const CI_SOURCE_OVER = 14;
const CI_EXCLUSIVE_OR = 15;

const CI_ALIGN_LEFTWARD = 0;
const CI_ALIGN_RIGHTWARD = 1;
const CI_ALIGN_CENTER = 2;
const CI_ALIGN_START = 0;
const CI_ALIGN_ENDING = 1;

const CI_BASELINE_ALPHABETIC = 0;
const CI_BASELINE_TOP = 1;
const CI_BASELINE_MIDDLE = 2;
const CI_BASELINE_BOTTOM = 3;
const CI_BASELINE_HANGING = 4;
const CI_BASELINE_IDEOGRAPHIC = 3;

const CI_FILL_NONZERO = 0;
const CI_FILL_EVENODD = 1;

// Base64 decode helper
function base64Decode(str) {
    const binary = atob(str);
    const bytes = new Uint8Array(binary.length);
    for (let i = 0; i < binary.length; i++)
        bytes[i] = binary.charCodeAt(i);
    return bytes;
}

// Load WASM module
const wasmScript = document.createElement('script');
wasmScript.src = 'canvas_ity.js';
wasmScript.onload = function() {
    if (typeof CanvasIty !== 'undefined') {
        CanvasIty().then(initWasm);
    } else {
        document.getElementById('status').textContent =
            'ERROR: Could not find CanvasIty module entry point.\n' +
            'Build with: make wasm';
    }
};
wasmScript.onerror = function() {
    document.getElementById('status').textContent =
        'ERROR: Failed to load canvas_ity.js.\n' +
        'Build with: emcc -O2 -s EXPORTED_FUNCTIONS=\'[...functions...]\' ' +
        '-s EXPORTED_RUNTIME_METHODS=\'["cwrap","ccall"]\' ' +
        'canvas_ity_wasm.c -o canvas_ity.js';
};
document.head.appendChild(wasmScript);

function initWasm(Module) {
    const status = document.getElementById('status');
    status.textContent = 'WASM module loaded. Running tests...\n';

    // cwrap bindings
    const ci = {};
    ci._malloc = Module._malloc;
    ci._free = Module._free;
    // Use getters to always get fresh heap views (ALLOW_MEMORY_GROWTH)
    Object.defineProperty(ci, 'HEAPU8', { get: function() { return Module.HEAPU8; } });
    Object.defineProperty(ci, 'HEAPF32', { get: function() { return Module.HEAPF32; } });
    Object.defineProperty(ci, 'HEAP32', { get: function() { return Module.HEAP32; } });

    ci.create = Module.cwrap('ci_canvas_create', 'number', ['number', 'number']);
    ci.destroy = Module.cwrap('ci_canvas_destroy', null, ['number']);
    ci.scale = Module.cwrap('ci_canvas_scale', null, ['number', 'number', 'number']);
    ci.rotate = Module.cwrap('ci_canvas_rotate', null, ['number', 'number']);
    ci.translate = Module.cwrap('ci_canvas_translate', null, ['number', 'number', 'number']);
    ci.transform = Module.cwrap('ci_canvas_transform', null, ['number', 'number', 'number', 'number', 'number', 'number', 'number']);
    ci.set_transform = Module.cwrap('ci_canvas_set_transform', null, ['number', 'number', 'number', 'number', 'number', 'number', 'number']);
    ci.set_global_alpha = Module.cwrap('ci_canvas_set_global_alpha', null, ['number', 'number']);
    ci.set_shadow_color = Module.cwrap('ci_canvas_set_shadow_color', null, ['number', 'number', 'number', 'number', 'number']);
    ci.set_shadow_blur = Module.cwrap('ci_canvas_set_shadow_blur', null, ['number', 'number']);
    ci.set_line_width = Module.cwrap('ci_canvas_set_line_width', null, ['number', 'number']);
    ci.set_miter_limit = Module.cwrap('ci_canvas_set_miter_limit', null, ['number', 'number']);
    ci.set_line_dash = Module.cwrap('ci_canvas_set_line_dash', null, ['number', 'number', 'number']);
    ci.set_color = Module.cwrap('ci_canvas_set_color', null, ['number', 'number', 'number', 'number', 'number', 'number']);
    ci.set_linear_gradient = Module.cwrap('ci_canvas_set_linear_gradient', null, ['number', 'number', 'number', 'number', 'number', 'number']);
    ci.set_radial_gradient = Module.cwrap('ci_canvas_set_radial_gradient', null, ['number', 'number', 'number', 'number', 'number', 'number', 'number', 'number']);
    ci.set_conic_gradient = Module.cwrap('ci_canvas_set_conic_gradient', null, ['number', 'number', 'number', 'number', 'number']);
    ci.add_color_stop = Module.cwrap('ci_canvas_add_color_stop', null, ['number', 'number', 'number', 'number', 'number', 'number', 'number']);
    ci.set_pattern = Module.cwrap('ci_canvas_set_pattern', null, ['number', 'number', 'number', 'number', 'number', 'number', 'number']);
    ci.begin_path = Module.cwrap('ci_canvas_begin_path', null, ['number']);
    ci.move_to = Module.cwrap('ci_canvas_move_to', null, ['number', 'number', 'number']);
    ci.close_path = Module.cwrap('ci_canvas_close_path', null, ['number']);
    ci.line_to = Module.cwrap('ci_canvas_line_to', null, ['number', 'number', 'number']);
    ci.quadratic_curve_to = Module.cwrap('ci_canvas_quadratic_curve_to', null, ['number', 'number', 'number', 'number', 'number']);
    ci.bezier_curve_to = Module.cwrap('ci_canvas_bezier_curve_to', null, ['number', 'number', 'number', 'number', 'number', 'number', 'number']);
    ci.arc_to = Module.cwrap('ci_canvas_arc_to', null, ['number', 'number', 'number', 'number', 'number', 'number']);
    ci.arc = Module.cwrap('ci_canvas_arc', null, ['number', 'number', 'number', 'number', 'number', 'number', 'number']);
    ci.ellipse = Module.cwrap('ci_canvas_ellipse', null, ['number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number']);
    ci.rectangle = Module.cwrap('ci_canvas_rectangle', null, ['number', 'number', 'number', 'number', 'number']);
    ci.round_rectangle = Module.cwrap('ci_canvas_round_rectangle', null, ['number', 'number', 'number', 'number', 'number', 'number', 'number']);
    ci.fill = Module.cwrap('ci_canvas_fill', null, ['number']);
    ci.stroke = Module.cwrap('ci_canvas_stroke', null, ['number']);
    ci.clip = Module.cwrap('ci_canvas_clip', null, ['number']);
    ci.is_point_in_path = Module.cwrap('ci_canvas_is_point_in_path', 'number', ['number', 'number', 'number']);
    ci.set_fill_rule = Module.cwrap('ci_canvas_set_fill_rule', null, ['number', 'number']);
    ci.clear_rectangle = Module.cwrap('ci_canvas_clear_rectangle', null, ['number', 'number', 'number', 'number', 'number']);
    ci.fill_rectangle = Module.cwrap('ci_canvas_fill_rectangle', null, ['number', 'number', 'number', 'number', 'number']);
    ci.stroke_rectangle = Module.cwrap('ci_canvas_stroke_rectangle', null, ['number', 'number', 'number', 'number', 'number']);
    ci.set_font = Module.cwrap('ci_canvas_set_font', 'number', ['number', 'number', 'number', 'number']);
    ci.fill_text = Module.cwrap('ci_canvas_fill_text', null, ['number', 'number', 'number', 'number', 'number']);
    ci.stroke_text = Module.cwrap('ci_canvas_stroke_text', null, ['number', 'number', 'number', 'number', 'number']);
    ci.measure_text = Module.cwrap('ci_canvas_measure_text', 'number', ['number', 'number']);
    ci.draw_image = Module.cwrap('ci_canvas_draw_image', null, ['number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number']);
    ci.get_image_data = Module.cwrap('ci_canvas_get_image_data', null, ['number', 'number', 'number', 'number', 'number', 'number', 'number']);
    ci.put_image_data = Module.cwrap('ci_canvas_put_image_data', null, ['number', 'number', 'number', 'number', 'number', 'number', 'number']);
    ci.save = Module.cwrap('ci_canvas_save', null, ['number']);
    ci.restore = Module.cwrap('ci_canvas_restore', null, ['number']);
    // Struct-member setter wrappers (must be exported by WASM C file)
    ci.set_line_cap = Module.cwrap('ci_wasm_set_line_cap', null, ['number', 'number']);
    ci.set_line_join = Module.cwrap('ci_wasm_set_line_join', null, ['number', 'number']);
    ci.set_line_dash_offset = Module.cwrap('ci_wasm_set_line_dash_offset', null, ['number', 'number']);
    ci.set_global_composite_operation = Module.cwrap('ci_wasm_set_composite_op', null, ['number', 'number']);
    ci.set_text_align = Module.cwrap('ci_wasm_set_text_align', null, ['number', 'number']);
    ci.set_text_baseline = Module.cwrap('ci_wasm_set_text_baseline', null, ['number', 'number']);
    ci.set_shadow_offset_x = Module.cwrap('ci_wasm_set_shadow_offset_x', null, ['number', 'number']);
    ci.set_shadow_offset_y = Module.cwrap('ci_wasm_set_shadow_offset_y', null, ['number', 'number']);
    ci.character_to_glyph = Module.cwrap('ci_wasm_character_to_glyph', 'number', ['number', 'number', 'number']);

    // Helper: allocate float array, return pointer
    function allocFloats(arr) {
        const ptr = ci._malloc(arr.length * 4);
        for (let i = 0; i < arr.length; i++)
            ci.HEAPF32[(ptr >> 2) + i] = arr[i];
        return ptr;
    }

    // Helper: set line dash
    function ciSetLineDash(ctx, segments) {
        if (segments.length === 0) {
            ci.set_line_dash(ctx, 0, 0);
            return;
        }
        const ptr = allocFloats(segments);
        ci.set_line_dash(ctx, ptr, segments.length);
        ci._free(ptr);
    }

    // Helper: set pattern from RGBA array
    function ciSetPattern(ctx, style, data, w, h, stride, repeat) {
        if (!data) {
            ci.set_pattern(ctx, style, 0, w, h, stride, repeat);
            return;
        }
        const ptr = ci._malloc(data.length);
        ci.HEAPU8.set(data, ptr);
        ci.set_pattern(ctx, style, ptr, w, h, stride, repeat);
        ci._free(ptr);
    }

    // Helper: set round rect radii
    function ciSetRoundRectRadii(ctx, x, y, w, h, radii) {
        const ptr = allocFloats(radii);
        ci.round_rectangle(ctx, x, y, w, h, ptr, radii.length);
        ci._free(ptr);
    }

    // Helper: set font from Uint8Array
    function ciSetFont(ctx, fontData, sizeOrPx, maybePx) {
        // Handle both: ciSetFont(ctx, data, px) and ciSetFont(ctx, 0, 0, px)
        let data = fontData, sz, px;
        if (maybePx !== undefined) {
            // Called as ciSetFont(ctx, data, size, px) - from raw translation
            sz = sizeOrPx;
            px = maybePx;
        } else {
            // Called as ciSetFont(ctx, data, px) - from clean translation
            px = sizeOrPx;
            sz = data ? data.length : 0;
        }
        if (!data || data === 0) {
            ci.set_font(ctx, 0, 0, px);
            return;
        }
        const ptr = ci._malloc(data.length);
        ci.HEAPU8.set(data, ptr);
        ci.set_font(ctx, ptr, sz, px);
        ci._free(ptr);
    }

    // Convert JS string to raw bytes (charCodeAt, not TextEncoder).
    // C strings with \xNN escapes are raw byte sequences (already UTF-8).
    // TextEncoder would re-encode \xNN as multi-byte UTF-8  wrong.
    function stringToBytes(text) {
        const bytes = new Uint8Array(text.length + 1);
        for (var i = 0; i < text.length; i++)
            bytes[i] = text.charCodeAt(i) & 0xFF;
        bytes[text.length] = 0;
        return bytes;
    }

    // Helper: fill_text with string
    function ciFillText(ctx, text, x, y, maxWidth) {
        const bytes = stringToBytes(text);
        const ptr = ci._malloc(bytes.length);
        ci.HEAPU8.set(bytes, ptr);
        ci.fill_text(ctx, ptr, x, y, maxWidth !== undefined ? maxWidth : 1e9);
        ci._free(ptr);
    }

    // Helper: stroke_text with string
    function ciStrokeText(ctx, text, x, y, maxWidth) {
        const bytes = stringToBytes(text);
        const ptr = ci._malloc(bytes.length);
        ci.HEAPU8.set(bytes, ptr);
        ci.stroke_text(ctx, ptr, x, y, maxWidth !== undefined ? maxWidth : 1e9);
        ci._free(ptr);
    }

    // Helper: measure_text with string
    function ciMeasureText(ctx, text) {
        const bytes = stringToBytes(text);
        const ptr = ci._malloc(bytes.length);
        ci.HEAPU8.set(bytes, ptr);
        const result = ci.measure_text(ctx, ptr);
        ci._free(ptr);
        return result;
    }

    // Helper: draw_image - ci_canvas_draw_image(ctx, image, w, h, stride, x, y, tw, th)
    // data can be a Uint8Array or 0/null for error testing
    function ciDrawImage(ctx, data, w, h, stride, x, y, tw, th) {
        if (!data || data === 0) {
            ci.draw_image(ctx, 0, w, h, stride, x, y, tw, th);
            return;
        }
        const ptr = ci._malloc(data.length);
        ci.HEAPU8.set(data, ptr);
        ci.draw_image(ctx, ptr, w, h, stride, x, y, tw, th);
        ci._free(ptr);
    }

    // Helper: get_image_data - ci_canvas_get_image_data(ctx, buf, w, h, stride, x, y)
    // Pass-through: just wraps the raw call. Callers manage memory.
    // For convenience, this version allocates, calls, copies, frees.
    function ciGetImageData(ctx, buf, w, h, stride, x, y) {
        // buf might be 0 (null) for error testing
        if (!buf || buf === 0) {
            ci.get_image_data(ctx, 0, w, h, stride, x, y);
            return null;
        }
        // buf is a WASM pointer (number) - call directly
        if (typeof buf === 'number') {
            ci.get_image_data(ctx, buf, w, h, stride, x, y);
            return;
        }
        // buf is a JS Uint8Array - allocate, copy in, call, copy back
        const ptr = ci._malloc(buf.length);
        ci.HEAPU8.set(buf, ptr);
        ci.get_image_data(ctx, ptr, w, h, stride, x, y);
        buf.set(new Uint8Array(ci.HEAPU8.buffer, ptr, buf.length));
        ci._free(ptr);
    }

    // Helper: put_image_data - ci_canvas_put_image_data(ctx, buf, w, h, stride, x, y)
    function ciPutImageData(ctx, data, w, h, stride, x, y) {
        if (!data || data === 0) {
            ci.put_image_data(ctx, 0, w, h, stride, x, y);
            return;
        }
        const ptr = ci._malloc(data.length);
        ci.HEAPU8.set(data, ptr);
        ci.put_image_data(ctx, ptr, w, h, stride, x, y);
        ci._free(ptr);
    }

    // Helper: render canvas_ity to an HTML canvas
    // Uses stride = w*4 for full-image read
    function ciRender(ctx, canvasId, w, h) {
        const stride = w * 4;
        const size = stride * h;
        const ptr = ci._malloc(size);
        ci.get_image_data(ctx, ptr, w, h, stride, 0, 0);
        const pixels = new Uint8ClampedArray(ci.HEAPU8.buffer, ptr, size).slice();
        ci._free(ptr);
        const htmlCanvas = document.getElementById(canvasId);
        if (!htmlCanvas) return;
        const ctx2d = htmlCanvas.getContext('2d');
        const imgData = ctx2d.createImageData(w, h);
        imgData.data.set(pixels);
        ctx2d.putImageData(imgData, 0, 0);
    }

    // Decoded font data

    const fontAData = base64Decode("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");
    const fontBData = base64Decode("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");
    const fontCData = base64Decode("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");
    const fontDData = base64Decode("AAEAAAA=");
    const fontEData = base64Decode("AAEAAAALAIAAAwAwT1MvMmisck8AAAE4AAAAYGNtYXAXewGCAAAB3AAAAUJjdnQgAEQFEQAAAyAAAAAEZ2x5ZjCUlAIAAANMAAAGhmhlYWQe1bIjAAAAvAAAADZoaGVhDf8FBAAAAPQAAAAkaG10eDmaBAMAAAGYAAAARGxvY2ERbxMOAAADJAAAAChtYXhwAHUAtwAAARgAAAAgbmFtZVZpNvsAAAnUAAAA23Bvc3T/aQBmAAAKsAAAAA==");
    const fontFData = base64Decode("AAEAAAALAIAAAwAwT1MvMmisck8AAAE4AAAAYGNtYXAXewGCAAAB3AAAAUJjdnQgAEQFEQAAAyAAAAAEZ2x5ZjCUlAIAAANMAAAGhmhlYWQe1bIjAAAAvAAAADZoaGVhDf8FBAAAAPQAAAAkaG10eDmaBAMAAAGYAAAARGxvY2ERbxMOAAADJAAAAChtYXhwAHUAtwAAARgAAAAgbmFtZVZpNvsAAAnUAAAA23Bvc3T/aQBmAAAKsAAAACAAAQAAAAEAAEPW4v5fDzz1AB0IAAAAAADcB1gvAAAAANwUDpf/+f5tB5AH8wAAAAgAAgAAAAAAAA==");
    const fontGData = base64Decode("AAEAAAABABAAAAAAaGVhZB7h+0cAAAAcAAAANgABAAAAAQAAC4VXZl8PPPUAHQgAAAAAANwHWC8AAAAA3CBXu//5/m0HkAfzAAAACAACAAAAAAAA");

    // Run a single WASM test: create canvas, run test fn, render to HTML canvas
    function runTest(name, w, h, testFn) {
        try {
            const ctx = ci.create(w, h);
            testFn(ctx, w, h);
            ciRender(ctx, name + '_wasm', w, h);
            ci.destroy(ctx);
            return true;
        } catch (e) {
            status.textContent += 'FAIL: ' + name + ': ' + e.message + '\n';
            return false;
        }
    }

    // =====================================================================
    // WASM test implementations (translated from test.c)
    // =====================================================================

    function wasm_scale_uniform(ctx, width, height) {
        let size;
            let segments = new Float32Array(1);
            segments[0] = 1.0;
            ci.set_color(ctx, CI_STROKE_STYLE, 0.0, 0.0, 0.0, 1.0);
            ciSetLineDash(ctx, Array.from(segments).slice(0, 1));
            ci.set_line_cap(ctx, CI_CAP_CIRCLE);
            for (size = 8.0; size < Math.min(width, height); size *= 2.0)
            {
                ci.scale(ctx, 2.0, 2.0);
                ci.stroke_rectangle(ctx, 0.0, 0.0, 8.0, 8.0);
            }
    }

    function wasm_scale_non_uniform(ctx, width, height) {
        let segments = new Float32Array(1);
            segments[0] = 4.0;
            ci.set_color(ctx, CI_STROKE_STYLE, 0.0, 0.0, 0.0, 1.0);
            ciSetLineDash(ctx, Array.from(segments).slice(0, 1));
            ci.scale(ctx, 4.0, 0.5);
            ci.stroke_rectangle(ctx, width * 0.125 / 4.0, height * 0.125 / 0.5,
                                       width * 0.75 / 4.0, height * 0.75 / 0.5);
    }

    function wasm_rotate(ctx, width, height) {
        let step;
            ci.set_color(ctx, CI_STROKE_STYLE, 0.0, 0.0, 0.0, 1.0);
            for (step = 0; step < 64; ++step)
            {
                ci.rotate(ctx, 3.14159265 / 2.0 / 64.0);
                ci.stroke_rectangle(ctx, 0.0, 0.0, width, height);
            }
    }

    function wasm_translate(ctx, width, height) {
        let step;
            ci.set_color(ctx, CI_STROKE_STYLE, 0.0, 0.0, 0.0, 1.0);
            for (step = 0.0; step < 32.0; step += 1.0)
            {
                ci.translate(ctx, (0.5 - step / 32.0) * width * 0.2,
                                    height / 32.0);
                ci.begin_path(ctx);
                ci.arc(ctx, 0.0, 0.0, width * 0.125, 0.0, 6.28318531, 0);
                ci.close_path(ctx);
                ci.stroke(ctx);
            }
    }

    function wasm_transform(ctx, width, height) {
        let step;
            ci.set_color(ctx, CI_STROKE_STYLE, 0.0, 0.0, 0.0, 1.0);
            for (step = 0; step < 8; ++step)
            {
                ci.transform(ctx, 1.0, 0.0, 0.1, 1.0, width * -0.05, 0.0);
                ci.stroke_rectangle(ctx, width * 0.25, height * 0.25,
                                           width * 0.5, height * 0.5);
            }
    }

    function wasm_transform_fill(ctx, width, height) {
        let checker = new Uint8Array(1024);
            let index;
            for (index = 0; index < 1024; ++index)
                checker[index] = (
                    ((index >> 5 & 1) ^ (index >> 9 & 1) ^
                     ((index & 3) == 3)) * 255);
            ciSetPattern(ctx, CI_FILL_STYLE, checker, 16, 16, 64, CI_REPEAT);
            ci.begin_path(ctx);
            ci.rectangle(ctx, width * 0.2, height * 0.2,
                                width * 0.6, height * 0.6);
            ci.transform(ctx, 1.0, 0.5, -0.5, 1.0, 0.0, 0.0);
            ci.fill(ctx);
    }

    function wasm_transform_stroke(ctx, width, height) {
        let segments = new Float32Array(4);
            segments[0] = 22.0; segments[1] = 8.0;
            segments[2] = 10.0; segments[3] = 8.0;
            ci.set_color(ctx, CI_STROKE_STYLE, 0.0, 0.0, 0.0, 1.0);
            ci.set_line_width(ctx, 8.0);
            ciSetLineDash(ctx, Array.from(segments).slice(0, 4));
            ci.begin_path(ctx);
            ci.arc(ctx, width * 0.5, height * 0.5, Math.min(width, height) * 0.4,
                          0.0, 6.28318531, 0);
            ci.close_path(ctx);
            ci.transform(ctx, 1.0, 1.0, 0.0, 2.0, 0.0, 0.0);
            ci.stroke(ctx);
    }

    function wasm_set_transform(ctx, width, height) {
        let step;
            ci.set_color(ctx, CI_STROKE_STYLE, 0.0, 0.0, 0.0, 1.0);
            for (step = 0; step < 8; ++step)
                ci.set_transform(ctx, 1.0, 0.0, 0.1, 1.0, width * -0.05, 0.0);
            ci.stroke_rectangle(ctx, width * 0.25, height * 0.25,
                                       width * 0.5, height * 0.5);
    }

    function wasm_global_alpha(ctx, width, height) {
        let y; let x;
            ci.set_color(ctx, CI_STROKE_STYLE, 0.0, 0.0, 0.0, 1.0);
            ci.set_line_width(ctx, 3.0);
            for (y = 0.0; y < 6.0; y += 1.0)
                for (x = 0.0; x < 6.0; x += 1.0)
                {
                    ci.set_color(ctx, CI_FILL_STYLE, x / 5.0, 1.0, y / 5.0, x / 5.0);
                    ci.set_global_alpha(ctx, y / 4.0 - 0.25);
                    ci.begin_path(ctx);
                    ci.rectangle(ctx,
                        (x + 0.1) / 6.0 * width, (y + 0.1) / 6.0 * height,
                        0.8 / 6.0 * width, 0.8 / 6.0 * height);
                    ci.fill(ctx);
                    ci.stroke(ctx);
                }
    }

    function wasm_global_composite_operation(ctx, width, height) {
        let operations = new Array(11);
            let box_width; let box_height;
            let index;
            operations[0] = CI_SOURCE_IN;
            operations[1] = CI_SOURCE_COPY;
            operations[2] = CI_SOURCE_OUT;
            operations[3] = CI_DESTINATION_IN;
            operations[4] = CI_DESTINATION_ATOP;
            operations[5] = CI_LIGHTER;
            operations[6] = CI_DESTINATION_OVER;
            operations[7] = CI_DESTINATION_OUT;
            operations[8] = CI_SOURCE_ATOP;
            operations[9] = CI_SOURCE_OVER;
            operations[10] = CI_EXCLUSIVE_OR;
            box_width = 0.25 * width;
            box_height = 0.25 * height;
            for (index = 0; index < 11; ++index)
            {
                let column = (operations[index] % 4);
                let row = Math.floor(operations[index] / 4);
                ci.save(ctx);
                ci.begin_path(ctx);
                ci.rectangle(ctx, column * box_width, row * box_height,
                                    box_width, box_height);
                ci.clip(ctx);
                ci.set_color(ctx, CI_FILL_STYLE, 0.0, 0.0, 1.0, 1.0);
                ci.fill_rectangle(ctx, (column + 0.4) * box_width,
                                         (row + 0.4) * box_height,
                                         0.4 * box_width, 0.4 * box_height);
                ci.set_global_composite_operation(ctx, operations[index]);
                ci.set_color(ctx, CI_FILL_STYLE, 1.0, 0.0, 0.0, 1.0);
                ci.fill_rectangle(ctx, (column + 0.2) * box_width,
                                         (row + 0.2) * box_height,
                                         0.4 * box_width, 0.4 * box_height);
                ci.restore(ctx);
            }
    }

    function wasm_shadow_color(ctx, width, height) {
        let row;
            ci.set_shadow_offset_x(ctx, 5.0);
            ci.set_shadow_offset_y(ctx, 5.0);
            ci.set_shadow_blur(ctx, 1.0);
            for (row = 0.0; row < 5.0; row += 1.0)
            {
                let y = (row + 0.25) * 0.2 * height;
                ci.set_color(ctx, CI_FILL_STYLE, 0.0, 0.0, 0.0, 0.25 * row);
                ci.set_shadow_color(ctx, 1.0, -1.0, 0.0, 0.25);
                ci.fill_rectangle(ctx, 0.05 * width, y,
                                         0.15 * width, 0.1 * height);
                ci.set_shadow_color(ctx, 0.0, 1.0, 0.0, 0.5);
                ci.fill_rectangle(ctx, 0.30 * width, y,
                                         0.15 * width, 0.1 * height);
                ci.set_shadow_color(ctx, 0.0, 0.0, 2.0, 0.75);
                ci.fill_rectangle(ctx, 0.55 * width, y,
                                         0.15 * width, 0.1 * height);
                ci.set_shadow_color(ctx, 1.0, 1.0, 1.0, 100.0);
                ci.fill_rectangle(ctx, 0.80 * width, y,
                                         0.15 * width, 0.1 * height);
            }
    }

    function wasm_shadow_offset(ctx, width, height) {
        let y; let x;
            ci.set_shadow_blur(ctx, 2.0);
            ci.set_color(ctx, CI_FILL_STYLE, 1.0, 1.0, 1.0, 1.0);
            ci.set_shadow_color(ctx, 0.0, 0.0, 0.0, 1.0);
            for (y = 0.0; y < 5.0; y += 1.0)
                for (x = 0.0; x < 5.0; x += 1.0)
                {
                    ci.set_shadow_offset_x(ctx, (x - 2.0) * 4.0);
                    ci.set_shadow_offset_y(ctx, (y - 2.0) * 4.0);
                    ci.fill_rectangle(ctx, (x + 0.25) * 0.2 * width,
                                             (y + 0.25) * 0.2 * height,
                                             0.1 * width, 0.1 * height);
                }
    }

    function wasm_shadow_offset_offscreen(ctx, width, height) {
        ci.set_shadow_offset_x(ctx, width);
            ci.set_color(ctx, CI_FILL_STYLE, 1.0, 0.0, 0.0, 1.0);
            ci.set_shadow_color(ctx, 0.0, 0.0, 0.0, 0.5);
            ci.fill_rectangle(ctx, width * -0.6875, height * 0.0625,
                                     width * 0.375, height * 0.375);
            ci.begin_path(ctx);
            ci.arc(ctx, width * 0.5, height * 0.75, Math.min(width, height) * 0.2,
                          0.0, 6.28318531, 0);
            ci.close_path(ctx);
            ci.fill(ctx);
    }

    function wasm_shadow_blur(ctx, width, height) {
        let x; let y;
            ci.set_color(ctx, CI_FILL_STYLE, 1.0, 1.0, 1.0, 1.0);
            ci.set_shadow_color(ctx, 0.0, 0.0, 0.0, 1.0);
            ci.set_shadow_offset_x(ctx, 5.0);
            ci.set_shadow_offset_y(ctx, 5.0);
            for (x = 0.0; x < 5.0; x += 1.0)
                for (y = 4.0; y >= 0.0; y -= 1.0)
                {
                    ci.set_shadow_blur(ctx, (y * 5.0 + x) * 0.5 - 0.5);
                    ci.fill_rectangle(ctx, (x + 0.25) * 0.2 * width,
                                             (y + 0.25) * 0.2 * height,
                                             0.1 * width, 0.1 * height);
                }
    }

    function wasm_shadow_blur_offscreen(ctx, width, height) {
        ci.set_color(ctx, CI_FILL_STYLE, 0.0, 0.0, 0.0, 1.0);
            ci.set_shadow_color(ctx, 0.0, 0.0, 0.0, 1.0);
            ci.set_shadow_blur(ctx, 5.0);
            ci.fill_rectangle(ctx, 0.0, height * 2.0, width, height);
            ci.fill_rectangle(ctx, 0.0, height * -2.0, width, height);
            ci.fill_rectangle(ctx, width + 1.0, 0.0, width, height);
            ci.fill_rectangle(ctx, -width - 1.0, 0.0, width, height);
    }

    function wasm_shadow_blur_composite(ctx, width, height) {
        let radius = Math.min(width, height) * 0.5;
            let dashing = new Float32Array(2);
            ci.arc(ctx, 0.5 * width, 0.5 * height, radius, 0.0, 6.28318531, 0);
            ci.clip(ctx);
            ci.set_color(ctx, CI_FILL_STYLE, 0.0, 0.0, 1.0, 1.0);
            ci.set_shadow_color(ctx, 0.0, 0.0, 0.0, 1.0);
            ci.fill_rectangle(ctx, 0.4 * width, 0.0, 0.2 * width, height);
            ci.set_global_composite_operation(ctx, CI_DESTINATION_ATOP);
            ci.set_color(ctx, CI_STROKE_STYLE, 1.0, 0.0, 0.0, 1.0);
            dashing[0] = 16.0; dashing[1] = 4.0;
            ciSetLineDash(ctx, Array.from(dashing).slice(0, 2));
            ci.set_line_width(ctx, 15.0);
            ci.set_shadow_offset_x(ctx, 5.0);
            ci.set_shadow_offset_y(ctx, 5.0);
            ci.set_shadow_blur(ctx, 6.0);
            ci.set_shadow_color(ctx, 0.0, 0.0, 0.0, 1.0);
            ci.begin_path(ctx);
            ci.arc(ctx, 0.45 * width, 0.85 * height, radius * 0.5, 0.0, 6.28318531, 0);
            ci.close_path(ctx);
            ci.stroke(ctx);
            ci.set_global_composite_operation(ctx, CI_SOURCE_OVER);
            ci.begin_path(ctx);
            ci.arc(ctx, 0.75 * width, 0.25 * height, radius, 0.0, 6.28318531, 0);
            ci.close_path(ctx);
            ci.stroke(ctx);
    }

    function wasm_line_width(ctx, width, height) {
        let step;
            ci.set_color(ctx, CI_STROKE_STYLE, 0.0, 0.0, 0.0, 1.0);
            ci.set_line_width(ctx, 4.0);
            for (step = 0.0; step < 16.0; step += 1.0)
            {
                let left = (step + 0.25) / 16.0 * width;
                let right = (step + 0.75) / 16.0 * width;
                ci.begin_path(ctx);
                ci.move_to(ctx, left, 0.0);
                ci.bezier_curve_to(ctx, left, 0.5 * height,
                                          right, 0.5 * height,
                                          right, height);
                ci.set_line_width(ctx, 0.5 * (step - 1));
                ci.stroke(ctx);
            }
            ci.set_color(ctx, CI_FILL_STYLE, 1.0, 1.0, 1.0, 1.0);
            ci.set_global_composite_operation(ctx, CI_SOURCE_ATOP);
            ci.fill_rectangle(ctx, 0.0, 0.5 * height, width, 0.5 * height);
            ci.set_global_composite_operation(ctx, CI_DESTINATION_OVER);
            ci.fill_rectangle(ctx, 0.0, 0.25 * height, width, 0.25 * height);
            ci.set_color(ctx, CI_FILL_STYLE, 0.0, 0.0, 0.0, 1.0);
            ci.fill_rectangle(ctx, 0.0, 0.5 * height, width, 0.25 * height);
    }

    function wasm_line_width_angular(ctx, width, height) {
        let step;
            for (step = 0.0; step < 5.0; step += 1.0)
            {
                let grey = (step + 1.0) / 5.0;
                ci.set_color(ctx, CI_STROKE_STYLE, grey, grey, grey, 1.0);
                ci.begin_path(ctx);
                ci.move_to(ctx, 0.1 * width, 0.1 * height);
                ci.bezier_curve_to(ctx, 1.2 * width, 1.0 * height,
                                          1.2 * width, -0.0 * height,
                                          0.1 * width, 0.9 * height);
                ci.set_line_width(ctx, 30.0 - 7.0 * step);
                ci.stroke(ctx);
            }
    }

    function wasm_line_cap(ctx, width, height) {
        let caps = new Array(3);
            let index;
            caps[0] = CI_CAP_BUTT; caps[1] = CI_CAP_SQUARE; caps[2] = CI_CAP_CIRCLE;
            ci.set_color(ctx, CI_STROKE_STYLE, 0.0, 0.0, 0.0, 1.0);
            ci.set_line_width(ctx, 24.0);
            for (index = 0; index < 3; ++index)
            {
                let right = (index + 1) / 3.0 * width - 20.0;
                ci.begin_path(ctx);
                ci.move_to(ctx, right, 0.125 * height);
                ci.bezier_curve_to(ctx, right, 0.125 * height + 100.0,
                                          right - 100.0, 0.875 * height,
                                          right, 0.875 * height);
                ci.set_line_cap(ctx, caps[index]);
                ci.stroke(ctx);
            }
    }

    function wasm_line_cap_offscreen(ctx, width, height) {
        let caps = new Array(3);
            let index;
            caps[0] = CI_CAP_BUTT; caps[1] = CI_CAP_SQUARE; caps[2] = CI_CAP_CIRCLE;
            ci.set_color(ctx, CI_STROKE_STYLE, 0.0, 0.0, 0.0, 1.0);
            ci.set_line_width(ctx, 36.0);
            for (index = 0; index < 3; ++index)
            {
                let x = ((index) + 0.5) / 3.0 * width;
                let y = ((index) + 0.5) / 3.0 * height;
                ci.begin_path(ctx);
                ci.move_to(ctx, x, -19.0);
                ci.line_to(ctx, x, -9.0);
                ci.move_to(ctx, x, height + 17.0);
                ci.line_to(ctx, x, height + 27.0);
                ci.move_to(ctx, -27.0, y);
                ci.line_to(ctx, -17.0, y);
                ci.move_to(ctx, width + 9.0, y);
                ci.line_to(ctx, width + 19.0, y);
                ci.set_line_cap(ctx, caps[index]);
                ci.stroke(ctx);
            }
    }

    function wasm_line_join(ctx, width, height) {
        let joins = new Array(3);
            let index;
            joins[0] = CI_JOIN_MITER; joins[1] = CI_JOIN_BEVEL; joins[2] = CI_JOIN_ROUNDED;
            ci.set_color(ctx, CI_STROKE_STYLE, 0.0, 0.0, 0.0, 1.0);
            ci.set_line_width(ctx, 16.0);
            for (index = 0; index < 3; ++index)
            {
                let left = ((index) + 0.25) / 3.0 * width;
                let right = ((index) + 0.75) / 3.0 * width;
                ci.begin_path(ctx);
                ci.move_to(ctx, left, 0.2 * height);
                ci.line_to(ctx, left, 0.1 * height);
                ci.line_to(ctx, left, 0.2 * height);
                ci.line_to(ctx, right, 0.2 * height);
                ci.line_to(ctx, left, 0.2 * height);
                ci.line_to(ctx, left, 0.3 * height);
                ci.line_to(ctx, right, 0.3 * height);
                ci.line_to(ctx, right, 0.4 * height);
                ci.line_to(ctx, right, 0.5 * height);
                ci.line_to(ctx, left, 0.4 * height);
                ci.line_to(ctx, left, 0.5 * height);
                ci.line_to(ctx, right, 0.6 * height);
                ci.bezier_curve_to(ctx, right, height,
                                          left, 0.4 * height,
                                          left, 0.7 * height);
                ci.bezier_curve_to(ctx, left, 0.8 * height,
                                          right, 0.8 * height,
                                          right, 0.9 * height);
                ci.set_line_join(ctx, joins[index]);
                ci.stroke(ctx);
            }
    }

    function wasm_line_join_offscreen(ctx, width, height) {
        let joins = new Array(3);
            let index;
            joins[0] = CI_JOIN_MITER; joins[1] = CI_JOIN_BEVEL; joins[2] = CI_JOIN_ROUNDED;
            ci.set_color(ctx, CI_STROKE_STYLE, 0.0, 0.0, 0.0, 1.0);
            ci.set_line_width(ctx, 36.0);
            for (index = 0; index < 3; ++index)
            {
                let x = ((index) + 0.5) / 3.0 * width;
                let y = ((index) + 0.5) / 3.0 * height;
                ci.begin_path(ctx);
                ci.move_to(ctx, x - 10.0, -55.0);
                ci.line_to(ctx, x - 10.0, -5.0);
                ci.line_to(ctx, x + 10.0, -55.0);
                ci.move_to(ctx, x - 10.0, height + 130.0);
                ci.line_to(ctx, x + 10.0, height + 80.0);
                ci.line_to(ctx, x + 10.0, height + 130.0);
                ci.move_to(ctx, -130.0, y - 10.0);
                ci.line_to(ctx, -80.0, y - 10.0);
                ci.line_to(ctx, -130.0, y + 10.0);
                ci.move_to(ctx, height + 55.0, y - 10.0);
                ci.line_to(ctx, height + 5.0, y + 10.0);
                ci.line_to(ctx, height + 55.0, y + 10.0);
                ci.set_line_join(ctx, joins[index]);
                ci.stroke(ctx);
            }
    }

    function wasm_miter_limit(ctx, width, height) {
        let line; let limit;
            ci.set_color(ctx, CI_STROKE_STYLE, 0.0, 0.0, 0.0, 1.0);
            for (line = 0.0; line < 4.0; line += 1.0)
            {
                ci.set_line_width(ctx, 1.5 * line + 1.0);
                ci.set_miter_limit(ctx, 20.0);
                for (limit = 0.0; limit < 8.0; limit += 1.0)
                {
                    let left = (limit + 0.2) / 8.0 * width;
                    let middle = (limit + 0.5) / 8.0 * width;
                    let right = (limit + 0.7) / 8.0 * width;
                    let top = (line + 0.3) / 4.0 * height;
                    let bottom = (line + 0.7) / 4.0 * height;
                    ci.begin_path(ctx);
                    ci.move_to(ctx, left, bottom);
                    ci.line_to(ctx, left, top);
                    ci.line_to(ctx, right, bottom);
                    ci.line_to(ctx, middle, top);
                    ci.set_miter_limit(ctx, 1.5 * limit);
                    ci.stroke(ctx);
                }
            }
    }

    function wasm_line_dash_offset(ctx, width, height) {
        let step;
            let segments = new Float32Array(4);
            segments[0] = 20.0; segments[1] = 8.0;
            segments[2] = 8.0; segments[3] = 8.0;
            ci.set_color(ctx, CI_STROKE_STYLE, 0.0, 0.0, 0.0, 1.0);
            ci.set_line_width(ctx, 6.0);
            ciSetLineDash(ctx, Array.from(segments).slice(0, 4));
            for (step = 0.0; step < 16.0; step += 1.0)
            {
                let left = (step + 0.125) / 16.0 * width;
                let right = (step + 0.875) / 16.0 * width;
                ci.begin_path(ctx);
                ci.move_to(ctx, left, 0.0);
                ci.line_to(ctx, right, 0.125 * height);
                ci.line_to(ctx, left, 0.375 * height);
                ci.line_to(ctx, right, 0.625 * height);
                ci.line_to(ctx, left, 0.875 * height);
                ci.line_to(ctx, right, height);
                ci.set_line_dash_offset(ctx, (step / 16.0 - 0.5) * 44.0);
                ci.stroke(ctx);
            }
    }

    function wasm_line_dash(ctx, width, height) {
        let segments_1 = new Float32Array(1); let segments_2 = new Float32Array(2); let segments_3 = new Float32Array(4); let segments_4 = new Float32Array(4);
            segments_1[0] = 10.0;
            ci.set_color(ctx, CI_STROKE_STYLE, 0.0, 0.0, 0.0, 1.0);
            ci.set_line_width(ctx, 6.0);
            ciSetLineDash(ctx, Array.from(segments_1).slice(0, 1));
            ci.stroke(ctx);
            ci.move_to(ctx, 0.0, 0.0);
            ci.stroke(ctx);
            ci.begin_path(ctx);
            ci.move_to(ctx, width * 0.25, 0.0);
            ci.line_to(ctx, width * 0.25, height);
            ci.stroke(ctx);
            segments_2[0] = 20.0; segments_2[1] = -8.0;
            ciSetLineDash(ctx, Array.from(segments_2).slice(0, 2));
            ci.begin_path(ctx);
            ci.move_to(ctx, width * 0.375, 0.0);
            ci.line_to(ctx, width * 0.375, height);
            ci.stroke(ctx);
            segments_3[0] = 20.0; segments_3[1] = 8.0; segments_3[2] = 8.0; segments_3[3] = 8.0;
            ciSetLineDash(ctx, Array.from(segments_3).slice(0, 4));
            ci.begin_path(ctx);
            ci.move_to(ctx, width * 0.5, 0.0);
            ci.line_to(ctx, width * 0.5, height);
            ci.stroke(ctx);
            segments_4[0] = 0.0; segments_4[1] = 8.0; segments_4[2] = 2.0; segments_4[3] = 8.0;
            ciSetLineDash(ctx, Array.from(segments_4).slice(0, 4));
            ci.begin_path(ctx);
            ci.move_to(ctx, width * 0.625, 0.0);
            ci.line_to(ctx, width * 0.625, height);
            ci.stroke(ctx);
            ciSetLineDash(ctx, []);
            ci.begin_path(ctx);
            ci.move_to(ctx, width * 0.75, 0.0);
            ci.line_to(ctx, width * 0.75, height);
            ci.stroke(ctx);
    }

    function wasm_line_dash_closed(ctx, width, height) {
        let segments_1 = new Float32Array(2); let segments_2 = new Float32Array(4);
            ci.set_color(ctx, CI_STROKE_STYLE, 0.0, 0.0, 0.0, 1.0);
            ci.set_line_width(ctx, 32.0);
            segments_1[0] = 96.0; segments_1[1] = 32.0;
            ciSetLineDash(ctx, Array.from(segments_1).slice(0, 2));
            ci.set_line_dash_offset(ctx, -80.0);
            ci.stroke_rectangle(ctx, 0.25 * width, 0.25 * height,
                                       0.5 * width, 0.5 * height);
            segments_2[0] = 96.0; segments_2[1] = 32.0; segments_2[2] = 1024.0; segments_2[3] = 16.0;
            ciSetLineDash(ctx, Array.from(segments_2).slice(0, 4));
            ci.set_line_dash_offset(ctx, 128.0);
            ci.stroke_rectangle(ctx, 0.09375 * width, 0.09375 * height,
                                       0.8125 * width, 0.8125 * height);
    }

    function wasm_line_dash_overlap(ctx, width, height) {
        let segments = new Float32Array(2);
            let index;
            ci.set_color(ctx, CI_STROKE_STYLE, 0.0, 0.0, 0.0, 1.0);
            ci.set_color(ctx, CI_FILL_STYLE, 1.0, 0.0, 0.0, 1.0);
            ci.set_line_cap(ctx, CI_CAP_CIRCLE);
            ci.set_line_width(ctx, 16.0);
            segments[0] = 14.0; segments[1] = 12.0;
            ciSetLineDash(ctx, Array.from(segments).slice(0, 2));
            for (index = 0; index < 4; ++index)
            {
                let flip = (index == 3 ? -1.0 : 1.0);
                let top_y = (index & 1 ? 0.25 : 0.1) * height;
                let bottom_y = (index & 1 ? 0.9 : 0.75) * height;
                let mid_x = (index & 2 ? 0.75 : 0.25) * width;
                let top_width = (index & 1 ? 0.25 : 0.55) * flip * width;
                let bottom_width = (index & 1 ? 0.55 : 0.25) * flip * width;
                ci.move_to(ctx, mid_x, top_y);
                ci.bezier_curve_to(ctx, mid_x - top_width, top_y,
                                          mid_x + bottom_width, bottom_y,
                                          mid_x, bottom_y);
                ci.bezier_curve_to(ctx, mid_x - bottom_width, bottom_y,
                                          mid_x + top_width, top_y,
                                          mid_x, top_y);
                ci.close_path(ctx);
            }
            ci.fill(ctx);
            ci.stroke(ctx);
    }

    function wasm_line_dash_offscreen(ctx, width, height) {
        let step;
            let segments = new Float32Array(4);
            ci.set_color(ctx, CI_STROKE_STYLE, 0.0, 0.0, 0.0, 1.0);
            ci.set_line_width(ctx, 6.0);
            segments[0] = 0.0;
            segments[1] = width * 20.5 * 3.14159265 - height * 0.5 + 1.0;
            segments[2] = height - 2.0;
            segments[3] = 0.0;
            ciSetLineDash(ctx, Array.from(segments).slice(0, 4));
            for (step = -2.0; step <= 2.0; step += 1.0)
            {
                ci.begin_path(ctx);
                ci.arc(ctx, width * -20.0, height * 0.5,
                              width * (20.5 - step * 0.1),
                              3.14159265, 1.5707963268, 0);
                ci.set_line_dash_offset(ctx, width * step * 0.1 * 3.14159265);
                ci.stroke(ctx);
            }
    }

    function wasm_color(ctx, width, height) {
        let radius = Math.min(width, height) * 0.4;
            ci.set_color(ctx, CI_FILL_STYLE, 2.0, -1.0, 0.0, 0.5);
            ci.set_color(ctx, CI_STROKE_STYLE, 0.0, 0.0, 1.0, 1.5);
            ci.set_line_width(ctx, 16.0);
            ci.arc(ctx, 0.5 * width, 0.5 * height, radius, 0.0, 6.28318531, 0);
            ci.close_path(ctx);
            ci.fill(ctx);
            ci.stroke(ctx);
    }

    function wasm_linear_gradient(ctx, width, height) {
        let radius = Math.min(width, height) * 0.4;
            ci.set_linear_gradient(ctx, CI_FILL_STYLE,
                                          0.3 * width, 0.3 * height,
                                          0.7 * width, 0.7 * height);
            ci.add_color_stop(ctx, CI_FILL_STYLE, 0.0, 0.0, 1.0, 0.0, 0.5);
            ci.add_color_stop(ctx, CI_FILL_STYLE, 1.0, 1.0, 0.0, 1.0, 100.0);
            ci.set_linear_gradient(ctx, CI_STROKE_STYLE,
                                          0.3 * width, 0.7 * height,
                                          0.7 * width, 0.3 * height);
            ci.add_color_stop(ctx, CI_STROKE_STYLE, 0.0, 0.0, 0.0, 1.0, 0.5);
            ci.add_color_stop(ctx, CI_STROKE_STYLE, 1.0, 1.0, 1.0, 0.0, 1.0);
            ci.set_line_width(ctx, 16.0);
            ci.arc(ctx, 0.5 * width, 0.5 * height, radius, 0.0, 6.28318531, 0);
            ci.close_path(ctx);
            ci.fill(ctx);
            ci.stroke(ctx);
            ci.set_linear_gradient(ctx, CI_STROKE_STYLE,
                                          0.5 * width, 0.5 * height,
                                          0.5 * width, 0.5 * height);
            ci.add_color_stop(ctx, CI_STROKE_STYLE, 0.0, 1.0, 0.0, 0.0, 0.5);
            ci.add_color_stop(ctx, CI_STROKE_STYLE, 1.0, 0.0, 1.0, 1.0, 1.0);
            ci.stroke(ctx);
    }

    function wasm_radial_gradient(ctx, width, height) {
        let radius = Math.min(width, height) * 0.4;
            ci.set_radial_gradient(ctx, CI_FILL_STYLE,
                                          0.0, 0.0, radius,
                                          width, height, 0.5 * radius);
            ci.add_color_stop(ctx, CI_FILL_STYLE, 0.0, 0.0, 1.0, 0.0, 0.5);
            ci.add_color_stop(ctx, CI_FILL_STYLE, 1.0, 1.0, 0.0, 1.0, 1.0);
            ci.set_radial_gradient(ctx, CI_STROKE_STYLE,
                                          0.0, height, radius,
                                          width, 0.0, 0.5 * radius);
            ci.add_color_stop(ctx, CI_STROKE_STYLE, 0.0, 0.0, 0.0, 1.0, 0.5);
            ci.add_color_stop(ctx, CI_STROKE_STYLE, 1.0, 1.0, 1.0, 0.0, 1.0);
            ci.set_line_width(ctx, 16.0);
            ci.arc(ctx, 0.5 * width, 0.5 * height, radius, 0.0, 6.28318531, 0);
            ci.close_path(ctx);
            ci.fill(ctx);
            ci.stroke(ctx);
            ci.set_radial_gradient(ctx, CI_STROKE_STYLE,
                                          0.5 * width, 0.4 * height, 10.0,
                                          0.5 * width, 0.6 * height, 0.0);
            ci.set_radial_gradient(ctx, CI_STROKE_STYLE,
                                          0.0, 0.5 * height, -10.0,
                                          width, 0.5 * height, 10.0);
            ci.add_color_stop(ctx, CI_STROKE_STYLE, 0.0, 1.0, 0.0, 0.0, 0.5);
            ci.add_color_stop(ctx, CI_STROKE_STYLE, 1.0, 0.0, 1.0, 1.0, 1.0);
            ci.stroke(ctx);
            ci.set_radial_gradient(ctx, CI_FILL_STYLE,
                                          0.5 * width, 0.5 * height, 0.0,
                                          0.5 * width, 0.5 * height, radius);
            ci.add_color_stop(ctx, CI_FILL_STYLE, 0.15, 0.0, 0.0, 0.0, 1.0);
            ci.add_color_stop(ctx, CI_FILL_STYLE, 0.20, 0.0, 0.0, 0.0, 0.0);
            ci.fill(ctx);
    }

    function wasm_conic_gradient(ctx, width, height) {
        let cx = 0.5 * width;
            let cy = 0.5 * height;
            let radius = Math.min(width, height) * 0.4;
            /* basic conic gradient: color wheel */
            ci.set_conic_gradient(ctx, CI_FILL_STYLE, 0.0, cx, cy);
            ci.add_color_stop(ctx, CI_FILL_STYLE, 0.0, 1.0, 0.0, 0.0, 1.0);
            ci.add_color_stop(ctx, CI_FILL_STYLE, 0.333, 0.0, 1.0, 0.0, 1.0);
            ci.add_color_stop(ctx, CI_FILL_STYLE, 0.667, 0.0, 0.0, 1.0, 1.0);
            ci.add_color_stop(ctx, CI_FILL_STYLE, 1.0, 1.0, 0.0, 0.0, 1.0);
            ci.arc(ctx, cx, cy, radius, 0.0, 6.28318531, 0);
            ci.close_path(ctx);
            ci.fill(ctx);
            /* conic gradient on stroke with offset start angle */
            ci.set_conic_gradient(ctx, CI_STROKE_STYLE,
                1.57079633, cx, cy);
            ci.add_color_stop(ctx, CI_STROKE_STYLE,
                0.0, 1.0, 1.0, 0.0, 1.0);
            ci.add_color_stop(ctx, CI_STROKE_STYLE,
                1.0, 0.0, 1.0, 1.0, 1.0);
            ci.set_line_width(ctx, 16.0);
            ci.stroke(ctx);
    }

    function wasm_conic_gradient_rect(ctx, width, height) {
        /* conic gradient filling a full rectangle */
            ci.set_conic_gradient(ctx, CI_FILL_STYLE,
                0.0, 0.5 * width, 0.5 * height);
            ci.add_color_stop(ctx, CI_FILL_STYLE,
                0.0, 0.0, 0.0, 0.0, 1.0);
            ci.add_color_stop(ctx, CI_FILL_STYLE,
                0.5, 1.0, 1.0, 1.0, 1.0);
            ci.add_color_stop(ctx, CI_FILL_STYLE,
                1.0, 0.0, 0.0, 0.0, 1.0);
            ci.fill_rectangle(ctx, 0.0, 0.0, width, height);
            /* offset start angle half-circle */
            ci.set_conic_gradient(ctx, CI_FILL_STYLE,
                3.14159265, 0.5 * width, 0.5 * height);
            ci.add_color_stop(ctx, CI_FILL_STYLE,
                0.0, 1.0, 0.0, 0.0, 0.8);
            ci.add_color_stop(ctx, CI_FILL_STYLE,
                0.5, 0.0, 0.0, 1.0, 0.8);
            ci.add_color_stop(ctx, CI_FILL_STYLE,
                1.0, 1.0, 0.0, 0.0, 0.8);
            ci.fill_rectangle(ctx, 0.0, 0.0, width, 0.5 * height);
    }

    function wasm_color_stop(ctx, width, height) {
        ci.add_color_stop(ctx, CI_FILL_STYLE, 0.5, 1.0, 0.0, 1.0, 1.0);
            ci.set_linear_gradient(ctx, CI_FILL_STYLE,
                                          0.1 * width, 0.0,
                                          0.9 * width, 0.0);
            ci.fill_rectangle(ctx, 0.0, 0.0, width, 0.1 * height);
            ci.add_color_stop(ctx, CI_FILL_STYLE, -1.0, 0.0, 1.0, 0.0, 1.0);
            ci.add_color_stop(ctx, CI_FILL_STYLE, 2.0, 1.0, 0.0, 0.0, 1.0);
            ci.add_color_stop(ctx, CI_FILL_STYLE, 0.3, -1.0, 0.0, 2.0, 2.0);
            ci.add_color_stop(ctx, CI_FILL_STYLE, 0.3, 1.0, 1.0, 1.0, 1.0);
            ci.add_color_stop(ctx, CI_FILL_STYLE, 0.3, 0.0, 0.0, 0.0, 1.0);
            ci.add_color_stop(ctx, CI_FILL_STYLE, 0.0, 0.0, 0.0, 0.8, 1.0);
            ci.add_color_stop(ctx, CI_FILL_STYLE, 1.0, 1.0, 1.0, 1.0, 1.0);
            ci.add_color_stop(ctx, CI_FILL_STYLE, 0.7, 0.9, 0.9, 0.9, 1.0);
            ci.add_color_stop(ctx, CI_FILL_STYLE, 0.6, 0.1, 0.1, 0.1, 1.0);
            ci.fill_rectangle(ctx, 0.0, 0.1 * height, width, 0.4 * height);
            ci.fill_rectangle(ctx, 0.0, 0.5 * height, width, 0.4 * height);
    }

    function wasm_pattern(ctx, width, height) {
        let checker = new Uint8Array(256);
            let index;
            let scale;
            for (index = 0; index < 256; ++index)
                checker[index] = (
                    (((index >> 2 & 1) ^ (index >> 5 & 1)) |
                     ((index & 3) == 3)) * 255);
            ci.arc(ctx, 0.5 * width, 0.5 * height, 32.0, 0.0, 6.28318531, 0);
            ci.close_path(ctx);
            ci.set_line_width(ctx, 20.0);
            ci.set_color(ctx, CI_STROKE_STYLE, 0.0, 0.0, 0.0, 1.0);
            ciSetPattern(ctx, CI_STROKE_STYLE, 0, 8, 8, 32, CI_REPEAT);
            ci.stroke(ctx);
            ci.set_line_width(ctx, 16.0);
            ciSetPattern(ctx, CI_STROKE_STYLE, checker, 8, 8, 32, CI_REPEAT);
            ci.stroke(ctx);
            for (scale = 8.0; scale >= 1.0; scale /= 2.0)
            {
                let size_x; let size_y;
                ci.set_transform(ctx, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0);
                ci.scale(ctx, scale, scale);
                size_x = 0.5 * width / scale;
                size_y = 0.5 * height / scale;
                ciSetPattern(ctx, CI_FILL_STYLE, checker, 8, 8, 32, CI_NO_REPEAT);
                ci.fill_rectangle(ctx, 0.0, 0.0, size_x, size_y);
                ciSetPattern(ctx, CI_FILL_STYLE, checker, 8, 8, 32, CI_REPEAT_X);
                ci.fill_rectangle(ctx, size_x, 0.0, size_x, size_y);
                ciSetPattern(ctx, CI_FILL_STYLE, checker, 8, 8, 32, CI_REPEAT_Y);
                ci.fill_rectangle(ctx, 0.0, size_y, size_x, size_y);
                ciSetPattern(ctx, CI_FILL_STYLE, checker, 8, 8, 32, CI_REPEAT);
                ci.fill_rectangle(ctx, size_x, size_y, size_x, size_y);
            }
    }

    function wasm_begin_path(ctx, width, height) {
        ci.move_to(ctx, 0.0, 0.0);
            ci.line_to(ctx, width, height);
            ci.stroke(ctx);
            ci.set_color(ctx, CI_STROKE_STYLE, 0.0, 0.0, 0.0, 1.0);
            ci.begin_path(ctx);
            ci.begin_path(ctx);
            ci.move_to(ctx, width, 0.0);
            ci.line_to(ctx, 0.0, height);
            ci.stroke(ctx);
            ci.begin_path(ctx);
            ci.line_to(ctx, 0.5 * width, height);
            ci.stroke(ctx);
    }

    function wasm_move_to(ctx, width, height) {
        ci.set_color(ctx, CI_STROKE_STYLE, 0.0, 0.0, 0.0, 1.0);
            ci.set_color(ctx, CI_FILL_STYLE, 1.0, 0.0, 0.0, 1.0);
            ci.set_line_width(ctx, 8.0);
            ci.move_to(ctx, 0.6 * width, height);
            ci.move_to(ctx, 0.4 * width, 0.1 * height);
            ci.line_to(ctx, 0.2 * width, 0.5 * height);
            ci.line_to(ctx, 0.4 * width, 0.9 * height);
            ci.move_to(ctx, 0.6 * width, 0.2 * height);
            ci.line_to(ctx, 0.8 * width, 0.4 * height);
            ci.move_to(ctx, 0.8 * width, 0.6 * height);
            ci.line_to(ctx, 0.6 * width, 0.8 * height);
            ci.move_to(ctx, 0.7 * width, 0.5 * height);
            ci.line_to(ctx, 0.7 * width, 0.5 * height);
            ci.fill(ctx);
            ci.stroke(ctx);
    }

    function wasm_close_path(ctx, width, height) {
        ci.set_color(ctx, CI_STROKE_STYLE, 0.0, 0.0, 0.0, 1.0);
            ci.set_color(ctx, CI_FILL_STYLE, 1.0, 0.0, 0.0, 1.0);
            ci.set_line_width(ctx, 8.0);
            ci.close_path(ctx);
            ci.line_to(ctx, 0.5 * width, 0.5 * height);
            ci.line_to(ctx, 0.2 * width, 0.8 * height);
            ci.line_to(ctx, 0.2 * width, 0.2 * height);
            ci.close_path(ctx);
            ci.line_to(ctx, 0.5 * width, 0.2 * height);
            ci.line_to(ctx, 0.8 * width, 0.2 * height);
            ci.close_path(ctx);
            ci.close_path(ctx);
            ci.move_to(ctx, 0.5 * width, 0.8 * height);
            ci.line_to(ctx, 0.8 * width, 0.8 * height);
            ci.line_to(ctx, 0.8 * width, 0.5 * height);
            ci.close_path(ctx);
            ci.fill(ctx);
            ci.stroke(ctx);
    }

    function wasm_line_to(ctx, width, height) {
        ci.set_color(ctx, CI_STROKE_STYLE, 0.0, 0.0, 0.0, 1.0);
            ci.set_color(ctx, CI_FILL_STYLE, 1.0, 0.0, 0.0, 1.0);
            ci.set_line_width(ctx, 16.0);
            ci.line_to(ctx, 0.1 * width, 0.2 * height);
            ci.line_to(ctx, 0.1 * width, 0.2 * height);
            ci.line_to(ctx, 0.2 * width, 0.5 * height);
            ci.line_to(ctx, 0.2 * width, 0.5 * height);
            ci.line_to(ctx, 0.3 * width, 0.8 * height);
            ci.line_to(ctx, 0.4 * width, 0.2 * height);
            ci.line_to(ctx, 0.4 * width, 0.2 * height);
            ci.line_to(ctx, 0.6 * width, 0.8 * height);
            ci.line_to(ctx, 0.6 * width, 0.8 * height);
            ci.move_to(ctx, 0.7 * width, 0.4 * height);
            ci.line_to(ctx, 0.9 * width, 0.4 * height);
            ci.line_to(ctx, 0.9 * width, 0.6 * height);
            ci.line_to(ctx, 0.7 * width, 0.6 * height);
            ci.line_to(ctx, 0.7 * width, 0.4 * height);
            ci.fill(ctx);
            ci.stroke(ctx);
    }

    function wasm_quadratic_curve_to(ctx, width, height) {
        ci.set_color(ctx, CI_STROKE_STYLE, 0.0, 0.0, 0.0, 1.0);
            ci.set_color(ctx, CI_FILL_STYLE, 1.0, 0.0, 0.0, 1.0);
            ci.set_line_width(ctx, 8.0);
            ci.quadratic_curve_to(ctx, 0.1 * width, 0.2 * height,
                                         0.1 * width, 0.2 * height);
            ci.quadratic_curve_to(ctx, 0.2 * width, 0.5 * height,
                                         0.2 * width, 0.5 * height);
            ci.quadratic_curve_to(ctx, 0.3 * width, 0.8 * height,
                                         0.4 * width, 0.2 * height);
            ci.quadratic_curve_to(ctx, 0.6 * width, 0.8 * height,
                                         0.7 * width, 0.2 * height);
            ci.move_to(ctx, 0.7 * width, 0.6 * height);
            ci.quadratic_curve_to(ctx, 0.9 * width, 0.6 * height,
                                         0.9 * width, 0.8 * height);
            ci.quadratic_curve_to(ctx, 0.9 * width, 0.9 * height,
                                         0.7 * width, 0.9 * height);
            ci.close_path(ctx);
            ci.move_to(ctx, 0.1 * width, 0.9 * height);
            ci.quadratic_curve_to(ctx, 0.5 * width, 0.5 * height,
                                         0.1 * width, 0.9 * height);
            ci.fill(ctx);
            ci.stroke(ctx);
    }

    function wasm_bezier_curve_to(ctx, width, height) {
        ci.set_color(ctx, CI_STROKE_STYLE, 0.0, 0.0, 0.0, 1.0);
            ci.set_color(ctx, CI_FILL_STYLE, 1.0, 0.0, 0.0, 1.0);
            ci.set_line_width(ctx, 8.0);
            ci.bezier_curve_to(ctx, 0.9 * width, 0.9 * height,
                                      0.6 * width, 0.6 * height,
                                      0.6 * width, 0.9 * height);
            ci.move_to(ctx, 0.1 * width, 0.1 * height);
            ci.bezier_curve_to(ctx, 0.9 * width, 0.9 * height,
                                      0.9 * width, 0.1 * height,
                                      0.1 * width, 0.9 * height);
            ci.move_to(ctx, 0.4 * width, 0.1 * height);
            ci.bezier_curve_to(ctx, 0.1 * width, 0.3 * height,
                                      0.7 * width, 0.3 * height,
                                      0.4 * width, 0.1 * height);
            ci.move_to(ctx, 0.9 * width, 0.1 * height);
            ci.bezier_curve_to(ctx, 0.6 * width, 0.2 * height,
                                      0.9 * width, 0.1 * height,
                                      0.6 * width, 0.2 * height);
            ci.move_to(ctx, 0.7 * width, 0.3 * height);
            ci.bezier_curve_to(ctx, 0.9 * width, 0.3 * height,
                                      0.9 * width, 0.4 * height,
                                      0.8 * width, 0.5 * height);
            ci.bezier_curve_to(ctx, 0.7 * width, 0.6 * height,
                                      0.7 * width, 0.7 * height,
                                      0.9 * width, 0.7 * height);
            ci.fill(ctx);
            ci.stroke(ctx);
    }

    function wasm_arc_to(ctx, width, height) {
        let radius = Math.min(width, height) * 0.5;
            ci.set_color(ctx, CI_STROKE_STYLE, 0.0, 0.0, 0.0, 1.0);
            ci.set_color(ctx, CI_FILL_STYLE, 1.0, 0.0, 0.0, 1.0);
            ci.set_line_width(ctx, 8.0);
            ci.arc_to(ctx, 0.3 * width, 0.3 * height,
                             0.5 * width, 0.5 * height, 16.0);
            ci.move_to(ctx, 0.4 * width, 0.4 * height);
            ci.arc_to(ctx, 0.7 * width, 0.1 * height,
                             0.7 * width, 0.4 * height, 0.0);
            ci.arc_to(ctx, 0.9 * width, 0.5 * height,
                             0.7 * width, 0.7 * height, 0.125 * radius);
            ci.arc_to(ctx, 0.5 * width, 0.9 * height,
                             0.3 * width, 0.8 * height, 0.25 * radius);
            ci.arc_to(ctx, 0.1 * width, 0.7 * height,
                             0.4 * width, 0.4 * height, 0.375 * radius);
            ci.close_path(ctx);
            ci.move_to(ctx, 0.1 * width, 0.6 * height);
            ci.transform(ctx, 1.0, -1.0, 0.0, 1.0, 0.0, 0.2 * height);
            ci.arc_to(ctx, 0.1 * width, 0.9 * height,
                             0.5 * width, 0.9 * height, 0.3 * radius);
            ci.set_transform(ctx, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0);
            ci.close_path(ctx);
            ci.move_to(ctx, 0.2 * width, 0.1 * height);
            ci.arc_to(ctx, 0.1 * width, 0.1 * height,
                             0.1 * width, 0.7 * height, 0.6 * radius);
            ci.arc_to(ctx, 0.2 * width, 0.4 * height,
                             0.2 * width, 0.4 * height, 0.5 * radius);
            ci.arc_to(ctx, 0.4 * width, 0.2 * height,
                             0.2 * width, 0.4 * height, 0.5 * radius);
            ci.arc_to(ctx, 0.5 * width, 0.5 * height,
                             0.9 * width, 0.1 * height, -1.0);
            ci.move_to(ctx, 0.6 * width, 0.9 * height);
            ci.set_transform(ctx, 0.0, 0.0, 0.0, 1.0, 0.9 * width, 0.0);
            ci.arc_to(ctx, 0.9 * width, 0.9 * height,
                             0.9 * width, 0.6 * height, 0.3 * radius);
            ci.set_transform(ctx, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0);
            ci.arc_to(ctx, 0.9 * width, 0.6 * height,
                             0.9 * width, 0.6 * height, 0.0);
            ci.fill(ctx);
            ci.stroke(ctx);
    }

    function wasm_arc(ctx, width, height) {
        let i; let j;
            for (i = 0; i < 4; ++i)
                for (j = 0; j < 3; ++j)
                {
                    let x = ((j) + 0.5) * width / 3.0;
                    let y = ((i) + 0.5) * height / 4.0;
                    let radius = Math.min(width, height) * 0.1;
                    let start = (3.14159265 + 1.0e-6) * (i % 2);
                    let end = (3.14159265 + 1.0e-6) * (1.0 + 0.5 * (j));
                    let counter = Math.trunc(i / 2);
                    ci.set_color(ctx, CI_STROKE_STYLE, 0.0, 0.0, 0.0, 1.0);
                    ci.set_color(ctx, CI_FILL_STYLE, 1.0, 0.0, 0.0, 1.0);
                    ci.set_line_width(ctx, 8.0);
                    ci.begin_path(ctx);
                    ci.arc(ctx, x, y, -radius, start, end, counter);
                    ci.arc(ctx, x, y, radius, start, end, counter);
                    ci.close_path(ctx);
                    ci.fill(ctx);
                    ci.stroke(ctx);
                }
    }

    function wasm_ellipse(ctx, width, height) {
        let i; let j;
            for (i = 0; i < 4; ++i)
                for (j = 0; j < 3; ++j)
                {
                    let x = ((j) + 0.5) * width / 3.0;
                    let y = ((i) + 0.5) * height / 4.0;
                    let rx = Math.min(width, height) * 0.12;
                    let ry = rx * 0.5;
                    let start = (3.14159265 + 1.0e-6) * (i % 2);
                    let end = (3.14159265 + 1.0e-6) * (1.0 + 0.5 * (j));
                    let counter = Math.trunc(i / 2);
                    ci.set_color(ctx, CI_STROKE_STYLE, 0.0, 0.0, 0.0, 1.0);
                    ci.set_color(ctx, CI_FILL_STYLE, 1.0, 0.0, 0.0, 1.0);
                    ci.set_line_width(ctx, 4.0);
                    ci.begin_path(ctx);
                    /* negative radius must be a no-op */
                    ci.ellipse(ctx, x, y, -rx, ry, 0.0,
                        start, end, counter);
                    ci.ellipse(ctx, x, y, rx, ry, 0.0,
                        start, end, counter);
                    ci.close_path(ctx);
                    ci.fill(ctx);
                    ci.stroke(ctx);
                }
    }

    function wasm_ellipse_rotated(ctx, width, height) {
        let cx = width * 0.5;
            let cy = height * 0.5;
            let rx = width * 0.35;
            let ry = height * 0.15;
            let pi = 3.14159265;
            let tau = 6.28318531;
            let i;
            ci.set_line_width(ctx, 3.0);
            /* draw three rotated filled ellipses at 0, 60, 120 degrees */
            for (i = 0; i < 3; ++i) {
                let rot = i * pi / 3.0;
                let r = (i == 0) ? 1.0 : 0.0;
                let g = (i == 1) ? 1.0 : 0.0;
                let b = (i == 2) ? 1.0 : 0.0;
                ci.set_color(ctx, CI_FILL_STYLE, r, g, b, 0.4);
                ci.set_color(ctx, CI_STROKE_STYLE, r, g, b, 1.0);
                ci.begin_path(ctx);
                ci.ellipse(ctx, cx, cy, rx, ry, rot,
                    0.0, tau, 0);
                ci.close_path(ctx);
                ci.fill(ctx);
                ci.stroke(ctx);
            }
    }

    function wasm_rectangle(ctx, width, height) {
        let y; let x;
            ci.set_color(ctx, CI_STROKE_STYLE, 0.0, 0.0, 0.0, 1.0);
            ci.set_color(ctx, CI_FILL_STYLE, 1.0, 0.0, 0.0, 1.0);
            ci.set_line_width(ctx, 8.0);
            ci.move_to(ctx, 0.3 * width, 0.3 * height);
            ci.line_to(ctx, 0.7 * width, 0.3 * height);
            ci.line_to(ctx, 0.7 * width, 0.7 * height);
            ci.line_to(ctx, 0.3 * width, 0.7 * height);
            ci.close_path(ctx);
            ci.move_to(ctx, 0.0, 0.0);
            for (y = -1.0; y <= 1.0; y += 1.0)
                for (x = -1.0; x <= 1.0; x += 1.0)
                    ci.rectangle(ctx, (0.5 + 0.1 * x) * width,
                                        (0.5 + 0.1 * y) * height,
                                        x * 0.3 * width, y * 0.3 * height);
            ci.line_to(ctx, width, height);
            ci.fill(ctx);
            ci.stroke(ctx);
    }

    function wasm_round_rect(ctx, width, height) {
        let r_uniform = 20.0;
            let radii4 = new Float32Array(4);
            ci.set_color(ctx, CI_STROKE_STYLE, 0.0, 0.0, 0.0, 1.0);
            ci.set_line_width(ctx, 3.0);
            /* Uniform radius */
            ci.set_color(ctx, CI_FILL_STYLE, 0.2, 0.4, 0.8, 1.0);
            ci.begin_path(ctx);
            ciSetRoundRectRadii(ctx, 15.0, 15.0, width - 30.0, height * 0.4 - 10.0, [r_uniform]);
            ci.fill(ctx);
            ci.stroke(ctx);
            /* Four different corner radii */
            radii4[0] = 5.0;
            radii4[1] = 15.0;
            radii4[2] = 30.0;
            radii4[3] = 40.0;
            ci.set_color(ctx, CI_FILL_STYLE, 0.8, 0.2, 0.2, 1.0);
            ci.begin_path(ctx);
            ciSetRoundRectRadii(ctx, 15.0, height * 0.5 + 5.0, width - 30.0, height * 0.4 - 10.0, Array.from(radii4).slice(0, 4));
            ci.fill(ctx);
            ci.stroke(ctx);
    }

    function wasm_round_rect_clamped(ctx, width, height) {
        let r_large = 200.0;
            let r_zero = 0.0;
            let radii_mixed = new Float32Array(4);
            ci.set_color(ctx, CI_STROKE_STYLE, 0.0, 0.0, 0.0, 1.0);
            ci.set_line_width(ctx, 2.0);
            /* Large radius: creates pill/capsule shape */
            ci.set_color(ctx, CI_FILL_STYLE, 0.2, 0.8, 0.2, 1.0);
            ci.begin_path(ctx);
            ciSetRoundRectRadii(ctx, 20.0, 15.0, width - 40.0, 60.0, [r_large]);
            ci.fill(ctx);
            ci.stroke(ctx);
            /* Zero radius: sharp corners like regular rect */
            ci.set_color(ctx, CI_FILL_STYLE, 0.4, 0.4, 0.8, 1.0);
            ci.begin_path(ctx);
            ciSetRoundRectRadii(ctx, 20.0, height * 0.33 + 10.0, width - 40.0, 60.0, [r_zero]);
            ci.fill(ctx);
            ci.stroke(ctx);
            /* Mixed large radii on small rect: all get scaled down */
            radii_mixed[0] = 100.0;
            radii_mixed[1] = 50.0;
            radii_mixed[2] = 30.0;
            radii_mixed[3] = 10.0;
            ci.set_color(ctx, CI_FILL_STYLE, 0.8, 0.8, 0.2, 1.0);
            ci.begin_path(ctx);
            ciSetRoundRectRadii(ctx, 30.0, height * 0.66 + 5.0, width - 60.0, 65.0, Array.from(radii_mixed).slice(0, 4));
            ci.fill(ctx);
            ci.stroke(ctx);
    }

    function wasm_fill(ctx, width, height) {
        let radius = Math.min(width, height) * 0.45;
            let step; let angle; let x; let y;
            ci.set_color(ctx, CI_FILL_STYLE, 0.0, 0.0, 0.0, 1.0);
            ci.fill(ctx);
            ci.begin_path(ctx);
            for (step = 0.0; step < 128.0; step += 1.0)
            {
                angle = step * (59.0 / 128.0 * 6.28318531);
                x = Math.cos(angle) * radius + width / 2.0;
                y = Math.sin(angle) * radius + height / 2.0;
                ci.line_to(ctx, x, y);
            }
            ci.close_path(ctx);
            ci.fill(ctx);
            ci.set_color(ctx, CI_FILL_STYLE, 1.0, 0.0, 0.0, 1.0);
            ci.scale(ctx, 0.0, 1.0);
            ci.fill(ctx);
    }

    function wasm_fill_rounding(ctx, width, height) {
        
            
            ci.set_color(ctx, CI_FILL_STYLE, 0.0, 0.0, 0.0, 1.0);
            ci.begin_path(ctx);
            ci.move_to(ctx, 4.00000191, 4.00000763);
            ci.line_to(ctx, 3.99999809, 192.0);
            ci.line_to(ctx, 28.0000019, 192.0);
            ci.close_path(ctx);
            ci.move_to(ctx, -10390.0664, 52.3311195);
            ci.line_to(ctx, -10389.9941, 47.6248589);
            ci.line_to(ctx, -10395.9941, 47.5328255);
            ci.line_to(ctx, -10396.0664, 52.2478294);
            ci.close_path(ctx);
            ci.move_to(ctx, 110.0, 256.0);
            ci.line_to(ctx, 124.086205, 255.998276);
            ci.line_to(ctx, 123.203453, 0.0);
            ci.close_path(ctx);
            ci.fill(ctx);
    }

    function wasm_fill_converging(ctx, width, height) {
        let radius = Math.min(width, height) * 0.48;
            let step; let angle_1; let angle_2;
            ci.set_color(ctx, CI_FILL_STYLE, 0.0, 0.0, 0.0, 1.0);
            for (step = 0.0; step < 256.0; step += 1.0)
            {
                angle_1 = (step + 0.0) / 256.0 * 6.28318531;
                angle_2 = (step + 0.5) / 256.0 * 6.28318531;
                ci.move_to(ctx, width / 2.0 + 0.5, height / 2.0 + 0.5);
                ci.line_to(ctx, Math.cos(angle_1) * radius + width  / 2.0 + 0.5,
                                  Math.sin(angle_1) * radius + height / 2.0 + 0.5);
                ci.line_to(ctx, Math.cos(angle_2) * radius + width  / 2.0 + 0.5,
                                  Math.sin(angle_2) * radius + height / 2.0 + 0.5);
                ci.close_path(ctx);
            }
            ci.fill(ctx);
    }

    function wasm_fill_zone_plate(ctx, width, height) {
        let radius = Math.floor((Math.min(width, height) * 0.48 / 4.0)) * 4.0;
            let step; let inner; let outer;
            ci.set_color(ctx, CI_FILL_STYLE, 0.0, 0.0, 0.0, 1.0);
            for (step = 0.0; step < radius; step += 2.0)
            {
                inner = Math.sqrt(((step + 0.0) / radius)) * radius;
                outer = Math.sqrt(((step + 1.0) / radius)) * radius;
                ci.move_to(ctx, width / 2.0 + inner, height / 2.0);
                ci.arc(ctx, width / 2.0, height / 2.0, inner,
                              0.0, 6.28318531, 0);
                ci.close_path(ctx);
                ci.move_to(ctx, width / 2.0 + outer, height / 2.0);
                ci.arc(ctx, width / 2.0, height / 2.0, outer,
                              6.28318531, 0.0, 1);
                ci.close_path(ctx);
            }
            ci.fill(ctx);
    }

    function wasm_stroke(ctx, width, height) {
        let radius = Math.min(width, height) * 0.45;
            let step; let angle; let x; let y;
            ci.set_color(ctx, CI_STROKE_STYLE, 0.0, 0.0, 0.0, 1.0);
            ci.stroke(ctx);
            ci.begin_path(ctx);
            for (step = 0.0; step < 128.0; step += 1.0)
            {
                angle = step * (59.0 / 128.0 * 6.28318531);
                x = Math.cos(angle) * radius + width / 2.0;
                y = Math.sin(angle) * radius + height / 2.0;
                ci.line_to(ctx, x, y);
            }
            ci.close_path(ctx);
            ci.stroke(ctx);
            ci.set_color(ctx, CI_STROKE_STYLE, 1.0, 0.0, 0.0, 1.0);
            ci.scale(ctx, 0.0, 1.0);
            ci.stroke(ctx);
    }

    function wasm_stroke_wide(ctx, width, height) {
        ci.scale(ctx, width / 256.0, height / 256.0);
            ci.set_line_join(ctx, CI_JOIN_ROUNDED);
            ci.move_to(ctx, 24.0, 104.0);
            ci.bezier_curve_to(ctx, 112.0, 24.0, 16.0, 24.0, 104.0, 104.0);
            ci.move_to(ctx, 152.0, 104.0);
            ci.bezier_curve_to(ctx, 232.8, 24.0, 151.2, 24.0, 232.0, 104.0);
            ci.move_to(ctx, 24.0, 232.0);
            ci.bezier_curve_to(ctx, 104.0, 152.0, 24.0, 152.0, 104.0, 232.0);
            ci.move_to(ctx, 188.0, 232.0);
            ci.bezier_curve_to(ctx, 196.0, 184.0, 188.0, 184.0, 196.0, 192.0);
            ci.set_line_width(ctx, 40.0);
            ci.stroke(ctx);
            ci.set_color(ctx, CI_STROKE_STYLE, 1.0, 0.0, 0.0, 1.0);
            ci.set_line_width(ctx, 1.0);
            ci.stroke(ctx);
    }

    function wasm_stroke_inner_join(ctx, width, height) {
        let joins = new Array(3);
            let index;
            joins[0] = CI_JOIN_MITER; joins[1] = CI_JOIN_BEVEL; joins[2] = CI_JOIN_ROUNDED;
            for (index = 0; index < 3; ++index)
            {
                let center = ((index) + 0.5) / 3.0 * width;
                ci.begin_path(ctx);
                ci.move_to(ctx, center - 0.05 * width, 0.275 * height);
                ci.line_to(ctx, center, 0.225 * height);
                ci.line_to(ctx, center + 0.025 * width, 0.25 * height);
                ci.move_to(ctx, center - 0.05 * width, 0.775 * height);
                ci.bezier_curve_to(ctx, center, 0.725 * height,
                                          center, 0.725 * height,
                                          center + 0.025 * width, 0.75 * height);
                ci.set_line_join(ctx, joins[index]);
                ci.set_color(ctx, CI_STROKE_STYLE, 0.0, 0.0, 0.0, 1.0);
                ci.set_line_width(ctx, 0.3 * width);
                ci.stroke(ctx);
                ci.set_color(ctx, CI_STROKE_STYLE, 1.0, 0.0, 0.0, 1.0);
                ci.set_line_width(ctx, 1.0);
                ci.stroke(ctx);
            }
    }

    function wasm_stroke_spiral(ctx, width, height) {
        let outside; let step; let parameter; let angle; let radius;
            ci.set_color(ctx, CI_STROKE_STYLE, 0.0, 0.0, 0.0, 1.0);
            ci.set_line_width(ctx, 2.0);
            ci.begin_path(ctx);
            outside = Math.min(width, height) * 0.48;
            for (step = 0.0; step <= 2048.0; step += 1.0)
            {
                parameter = (step - 1024.0) / 1024.0;
                angle = Math.abs(parameter) * 12.0 * 6.28318531;
                radius = parameter * outside;
                ci.line_to(ctx, Math.cos(angle) * radius + width * 0.5,
                                  Math.sin(angle) * radius + height * 0.5);
            }
            ci.stroke(ctx);
    }

    function wasm_stroke_long(ctx, width, height) {
        let step;
            ci.set_color(ctx, CI_STROKE_STYLE, 0.0, 0.0, 0.0, 1.0);
            for (step = 0.0; step <= 29.0; step += 1.0)
            {
                ci.move_to(ctx, 0.4 * width, -23.0 * height);
                ci.line_to(ctx, width * step / 29.0, height);
                ci.move_to(ctx, -23.0 * width, 0.4 * height);
                ci.line_to(ctx, width, height * step / 29.0);
            }
            ci.stroke(ctx);
    }

    function wasm_clip(ctx, width, height) {
        let radius = Math.min(width, height) * 0.5;
            let step;
            ci.set_line_width(ctx, 8.0);
            for (step = 0; step < 8; ++step)
            {
                let fraction = (step) / 8.0;
                let angle = fraction * 6.28318531;
                ci.set_color(ctx, CI_STROKE_STYLE,
                                    0.0, (step & 1), 0.0, 1.0);
                ci.begin_path(ctx);
                ci.arc(ctx, 0.5 * width + 0.8 * radius * Math.cos(angle),
                              0.5 * height + 0.8 * radius * Math.sin(angle),
                              radius, 0.0, 6.28318531, 0);
                ci.close_path(ctx);
                ci.stroke(ctx);
                ci.clip(ctx);
            }
            ci.begin_path(ctx);
            ci.clip(ctx);
            ci.set_color(ctx, CI_FILL_STYLE, 1.0, 0.0, 1.0, 1.0);
            ci.fill_rectangle(ctx, 0.0, 0.0, width, height);
    }

    function wasm_clip_winding(ctx, width, height) {
        let step;
            ci.move_to(ctx, 0.125 * width, 0.125 * height);
            ci.line_to(ctx, 0.625 * width, 0.125 * height);
            ci.line_to(ctx, 0.625 * width, 0.625 * height);
            ci.line_to(ctx, 0.125 * width, 0.625 * height);
            ci.move_to(ctx, 0.250 * width, 0.250 * height);
            ci.line_to(ctx, 0.750 * width, 0.250 * height);
            ci.line_to(ctx, 0.750 * width, 0.750 * height);
            ci.line_to(ctx, 0.250 * width, 0.750 * height);
            ci.move_to(ctx, 0.375 * width, 0.375 * height);
            ci.line_to(ctx, 0.375 * width, 0.875 * height);
            ci.line_to(ctx, 0.875 * width, 0.875 * height);
            ci.line_to(ctx, 0.875 * width, 0.375 * height);
            ci.set_color(ctx, CI_FILL_STYLE, 1.0, 0.0, 0.0, 1.0);
            ci.fill(ctx);
            ci.clip(ctx);
            ci.set_line_width(ctx, 4.0);
            ci.stroke(ctx);
            ci.set_line_width(ctx, 6.0);
            ci.begin_path(ctx);
            for (step = 0.0; step < 32.0; step += 1.0)
            {
                ci.move_to(ctx, step / 16.0 * width, 0.0);
                ci.line_to(ctx, step / 16.0 * width - width, height);
            }
            ci.stroke(ctx);
    }

    function wasm_is_point_in_path(ctx, width, height) {
        let index;
            ci.set_color(ctx, CI_FILL_STYLE, 0.0, 0.0, 1.0, 1.0);
            ci.set_color(ctx, CI_STROKE_STYLE, 1.0, 1.0, 1.0, 1.0);
            if (ci.is_point_in_path(ctx, 0.0, 0.0))
                ci.fill_rectangle(ctx, 0.0, 0.0, 16.0, 16.0);
            ci.scale(ctx, width / 256.0, height / 256.0);
            ci.begin_path(ctx);
            ci.move_to(ctx, 65.0, 16.0);
            ci.line_to(ctx, 113.0, 24.0);
            ci.bezier_curve_to(ctx, 113.0, 24.0, 93.0, 126.0, 119.0, 160.0);
            ci.bezier_curve_to(ctx, 133.0, 180.0, 170.0, 196.0, 186.0, 177.0);
            ci.bezier_curve_to(ctx, 198.0, 162.0, 182.0, 130.0, 166.0, 118.0);
            ci.bezier_curve_to(ctx, 123.0, 80.0, 84.0, 124.0, 84.0, 124.0);
            ci.line_to(ctx, 35.0, 124.0);
            ci.line_to(ctx, 18.0, 56.0);
            ci.line_to(ctx, 202.0, 56.0);
            ci.line_to(ctx, 202.0, 90.0);
            ci.bezier_curve_to(ctx, 202.0, 90.0, 240.0, 168.0, 209.0, 202.0);
            ci.bezier_curve_to(ctx, 175.0, 240.0, 65.0, 187.0, 65.0, 187.0);
            ci.close_path(ctx);
            ci.translate(ctx, 40.0, 160.0);
            ci.move_to(ctx, 110.0, 0.0);
            ci.line_to(ctx, 0.0, 0.0);
            ci.line_to(ctx, 0.0, 0.0);
            ci.bezier_curve_to(ctx, 0.0, 90.0, 110.0, 90.0, 110.0, 40.0);
            ci.close_path(ctx);
            ci.fill(ctx);
            ci.stroke(ctx);
            for (index = 0; index < 256; ++index)
            {
                let bits = index;
                let inside;
                let x; let y;
                bits = (bits << 1 & 0xaa) | (bits >> 1 & 0x55);
                bits = (bits << 2 & 0xcc) | (bits >> 2 & 0x33);
                bits = (bits << 4 & 0xf0) | (bits >> 4 & 0x0f);
                x = (bits) / 256.0 * width;
                y = (index) / 256.0 * height;
                ci.rotate(ctx, 0.5);
                inside = ci.is_point_in_path(ctx, x, y);
                ci.set_transform(ctx, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0);
                ci.set_color(ctx, CI_STROKE_STYLE, 1.0 - inside, inside, 0.0, 1.0);
                ci.stroke_rectangle(ctx, x - 1.5, y - 1.5, 3.0, 3.0);
            }
    }

    function wasm_is_point_in_path_offscreen(ctx, width, height) {
        let index;
            ci.set_color(ctx, CI_FILL_STYLE, 0.0, 0.0, 1.0, 1.0);
            ci.set_color(ctx, CI_STROKE_STYLE, 1.0, 1.0, 1.0, 1.0);
            ci.scale(ctx, width / 256.0, height / 256.0);
            ci.begin_path(ctx);
            ci.move_to(ctx, 321.0, -240.0);
            ci.line_to(ctx, 369.0, -232.0);
            ci.bezier_curve_to(ctx, 369.0, -232.0, 349.0, -130.0, 375.0, -96.0);
            ci.bezier_curve_to(ctx, 389.0, -76.0, 426.0, -60.0, 442.0, -79.0);
            ci.bezier_curve_to(ctx, 454.0, -94.0, 438.0, -126.0, 422.0, -138.0);
            ci.bezier_curve_to(ctx, 379.0, -176.0, 340.0, -132.0, 340.0, -132.0);
            ci.line_to(ctx, 291.0, -132.0);
            ci.line_to(ctx, 274.0, -200.0);
            ci.line_to(ctx, 458.0, -200.0);
            ci.line_to(ctx, 458.0, -166.0);
            ci.bezier_curve_to(ctx, 458.0, -166.0, 496.0, -88.0, 465.0, -54.0);
            ci.bezier_curve_to(ctx, 431.0, -16.0, 321.0, -69.0, 321.0, -69.0);
            ci.close_path(ctx);
            ci.translate(ctx, 40.0, 160.0);
            ci.move_to(ctx, 366.0, -256.0);
            ci.line_to(ctx, 256.0, -256.0);
            ci.line_to(ctx, 256.0, -256.0);
            ci.bezier_curve_to(ctx, 256.0, -166.0, 366.0, -166.0, 366.0, -216.0);
            ci.close_path(ctx);
            ci.fill(ctx);
            ci.stroke(ctx);
            for (index = 0; index < 256; ++index)
            {
                let bits = index;
                let inside;
                let x; let y;
                bits = (bits << 1 & 0xaa) | (bits >> 1 & 0x55);
                bits = (bits << 2 & 0xcc) | (bits >> 2 & 0x33);
                bits = (bits << 4 & 0xf0) | (bits >> 4 & 0x0f);
                x = (bits) / 256.0 * width;
                y = (index) / 256.0 * height;
                ci.rotate(ctx, 0.5);
                inside = ci.is_point_in_path(ctx, x + width, y - height);
                ci.set_transform(ctx, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0);
                ci.set_color(ctx, CI_STROKE_STYLE, 1.0 - inside, inside, 0.0, 1.0);
                ci.stroke_rectangle(ctx, x - 1.5, y - 1.5, 3.0, 3.0);
            }
    }

    function wasm_fill_evenodd(ctx, width, height) {
        /* Concentric circles, all wound the same direction.
               Nonzero fills solid; evenodd alternates filled/unfilled rings. */
            let cx = width * 0.5;
            let cy = height * 0.5;
            let radii = new Float32Array(5);
            let i;
            radii[0] = Math.min(width, height) * 0.45;
            radii[1] = Math.min(width, height) * 0.36;
            radii[2] = Math.min(width, height) * 0.27;
            radii[3] = Math.min(width, height) * 0.18;
            radii[4] = Math.min(width, height) * 0.09;
            ci.set_color(ctx, CI_FILL_STYLE, 0.0, 0.0, 0.0, 1.0);
            ci.set_fill_rule(ctx, CI_FILL_EVENODD);
            ci.begin_path(ctx);
            for (i = 0; i < 5; ++i) {
                ci.move_to(ctx, cx + radii[i], cy);
                ci.arc(ctx, cx, cy, radii[i], 0.0, 6.28318531, 0);
                ci.close_path(ctx);
            }
            ci.fill(ctx);
    }

    function wasm_fill_evenodd_star(ctx, width, height) {
        /* Five-pointed star drawn as a single self-intersecting polygon.
               With evenodd, the center pentagon is unfilled. */
            let cx = width * 0.5;
            let cy = height * 0.5;
            let r = Math.min(width, height) * 0.45;
            let order = new Int32Array(5);
            let i;
            order[0] = 0; order[1] = 2; order[2] = 4; order[3] = 1; order[4] = 3;
            ci.set_color(ctx, CI_FILL_STYLE, 0.0, 0.0, 0.0, 1.0);
            ci.set_fill_rule(ctx, CI_FILL_EVENODD);
            ci.begin_path(ctx);
            for (i = 0; i < 5; ++i) {
                let angle = order[i] * 1.25663706 - 1.57079633;
                let px = cx + r * Math.cos(angle);
                let py = cy + r * Math.sin(angle);
                if (i == 0)
                    ci.move_to(ctx, px, py);
                else
                    ci.line_to(ctx, px, py);
            }
            ci.close_path(ctx);
            ci.fill(ctx);
    }

    function wasm_clip_evenodd(ctx, width, height) {
        /* Clip with evenodd on concentric circles, then fill a rectangle.
               Only the alternating rings should be visible. */
            let cx = width * 0.5;
            let cy = height * 0.5;
            let radii = new Float32Array(4);
            let i;
            radii[0] = Math.min(width, height) * 0.45;
            radii[1] = Math.min(width, height) * 0.33;
            radii[2] = Math.min(width, height) * 0.21;
            radii[3] = Math.min(width, height) * 0.09;
            ci.set_fill_rule(ctx, CI_FILL_EVENODD);
            ci.begin_path(ctx);
            for (i = 0; i < 4; ++i) {
                ci.move_to(ctx, cx + radii[i], cy);
                ci.arc(ctx, cx, cy, radii[i], 0.0, 6.28318531, 0);
                ci.close_path(ctx);
            }
            ci.clip(ctx);
            ci.set_color(ctx, CI_FILL_STYLE, 0.0, 0.0, 0.0, 1.0);
            ci.fill_rectangle(ctx, 0.0, 0.0, width, height);
    }

    function wasm_is_point_in_path_evenodd(ctx, width, height) {
        /* Test is_point_in_path with evenodd on concentric rectangles.
               Points in odd rings = inside, even rings = outside. */
            let index;
            ci.set_color(ctx, CI_FILL_STYLE, 0.0, 0.0, 1.0, 1.0);
            ci.set_color(ctx, CI_STROKE_STYLE, 1.0, 1.0, 1.0, 1.0);
            ci.scale(ctx, width / 256.0, height / 256.0);
            ci.set_fill_rule(ctx, CI_FILL_EVENODD);
            ci.begin_path(ctx);
            ci.rectangle(ctx, 16.0, 16.0, 224.0, 224.0);
            ci.rectangle(ctx, 48.0, 48.0, 160.0, 160.0);
            ci.rectangle(ctx, 80.0, 80.0, 96.0, 96.0);
            ci.fill(ctx);
            for (index = 0; index < 256; ++index)
            {
                let bits = index;
                let inside;
                let x; let y;
                bits = (bits << 1 & 0xaa) | (bits >> 1 & 0x55);
                bits = (bits << 2 & 0xcc) | (bits >> 2 & 0x33);
                bits = (bits << 4 & 0xf0) | (bits >> 4 & 0x0f);
                x = (bits);
                y = (index);
                inside = ci.is_point_in_path(ctx, x, y);
                ci.set_color(ctx, CI_STROKE_STYLE, 1.0 - inside, inside, 0.0, 1.0);
                ci.stroke_rectangle(ctx, x - 1.5, y - 1.5, 3.0, 3.0);
            }
    }

    function wasm_clear_rectangle(ctx, width, height) {
        let y; let x;
            ci.set_color(ctx, CI_STROKE_STYLE, 1.0, 1.0, 1.0, 1.0);
            ci.set_color(ctx, CI_FILL_STYLE, 0.4, 0.05, 0.2, 1.0);
            ci.move_to(ctx, 0.0, 0.0);
            ci.line_to(ctx, width, 0.0);
            ci.line_to(ctx, width, height);
            ci.line_to(ctx, 0.0, height);
            ci.fill(ctx);
            ci.rotate(ctx, 0.2);
            ci.begin_path(ctx);
            ci.move_to(ctx, 0.2 * width, 0.2 * height);
            ci.line_to(ctx, 0.8 * width, 0.2 * height);
            ci.line_to(ctx, 0.8 * width, 0.8 * height);
            ci.set_shadow_offset_x(ctx, 5.0);
            ci.set_shadow_color(ctx, 0.0, 0.0, 0.0, 1.0);
            ci.set_global_composite_operation(ctx, CI_DESTINATION_ATOP);
            ci.set_global_alpha(ctx, 0.5);
            for (y = -1.0; y <= 1.0; y += 1.0)
                for (x = -1.0; x <= 1.0; x += 1.0)
                    ci.clear_rectangle(ctx, (0.5 + 0.05 * x) * width,
                                              (0.5 + 0.05 * y) * height,
                                              x * 0.2 * width, y * 0.2 * height);
            ci.set_global_alpha(ctx, 1.0);
            ci.set_global_composite_operation(ctx, CI_SOURCE_OVER);
            ci.set_shadow_color(ctx, 0.0, 0.0, 0.0, 0.0);
            ci.line_to(ctx, 0.2 * width, 0.8 * height);
            ci.close_path(ctx);
            ci.stroke(ctx);
    }

    function wasm_fill_rectangle(ctx, width, height) {
        let y; let x;
            ci.set_color(ctx, CI_STROKE_STYLE, 0.0, 0.0, 0.0, 1.0);
            ci.set_color(ctx, CI_FILL_STYLE, 0.4, 0.05, 0.2, 1.0);
            ci.rotate(ctx, 0.2);
            ci.move_to(ctx, 0.2 * width, 0.2 * height);
            ci.line_to(ctx, 0.8 * width, 0.2 * height);
            ci.line_to(ctx, 0.8 * width, 0.8 * height);
            for (y = -1.0; y <= 1.0; y += 1.0)
                for (x = -1.0; x <= 1.0; x += 1.0)
                    ci.fill_rectangle(ctx, (0.5 + 0.05 * x) * width,
                                             (0.5 + 0.05 * y) * height,
                                             x * 0.2 * width, y * 0.2 * height);
            ci.line_to(ctx, 0.2 * width, 0.8 * height);
            ci.close_path(ctx);
            ci.stroke(ctx);
    }

    function wasm_stroke_rectangle(ctx, width, height) {
        let y; let x;
            ci.set_color(ctx, CI_STROKE_STYLE, 0.0, 0.0, 0.0, 1.0);
            ci.rotate(ctx, 0.2);
            ci.begin_path(ctx);
            ci.move_to(ctx, 0.2 * width, 0.2 * height);
            ci.line_to(ctx, 0.8 * width, 0.2 * height);
            ci.line_to(ctx, 0.8 * width, 0.8 * height);
            for (y = -1.0; y <= 1.0; y += 1.0)
                for (x = -1.0; x <= 1.0; x += 1.0)
                    ci.stroke_rectangle(ctx, (0.5 + 0.05 * x) * width,
                                               (0.5 + 0.05 * y) * height,
                                               x * 0.2 * width, y * 0.2 * height);
            ci.line_to(ctx, 0.2 * width, 0.8 * height);
            ci.close_path(ctx);
            ci.stroke(ctx);
    }

    function wasm_text_align(ctx, width, height) {
        let alignments = new Array(5);
            let index;
            alignments[0] = CI_ALIGN_LEFTWARD; alignments[1] = CI_ALIGN_CENTER;
            alignments[2] = CI_ALIGN_RIGHTWARD; alignments[3] = CI_ALIGN_START;
            alignments[4] = CI_ALIGN_ENDING;
            ciSetFont(ctx, fontAData, 0.2 * height);
            ci.rotate(ctx, 0.2);
            ci.set_color(ctx, CI_FILL_STYLE, 0.0, 0.0, 0.0, 1.0);
            for (index = 0; index < 5; ++index)
            {
                let base = (0.1 + 0.2 * (index)) * height;
                ci.set_text_align(ctx, alignments[index]);
                ciFillText(ctx, "HIty", 0.5 * width, base, 1.0e30);
            }
            ci.set_color(ctx, CI_STROKE_STYLE, 1.0, 0.0, 0.0, 0.5);
            ci.set_line_width(ctx, 1.0);
            ci.move_to(ctx, 0.0, 0.5 * height);
            ci.line_to(ctx, width, 0.5 * height);
            ci.move_to(ctx, 0.5 * width, 0.0);
            ci.line_to(ctx, 0.5 * width, height);
            ci.stroke(ctx);
    }

    function wasm_text_baseline(ctx, width, height) {
        let baselines = new Array(6);
            let index;
            baselines[0] = CI_BASELINE_ALPHABETIC; baselines[1] = CI_BASELINE_TOP;
            baselines[2] = CI_BASELINE_MIDDLE; baselines[3] = CI_BASELINE_BOTTOM;
            baselines[4] = CI_BASELINE_HANGING; baselines[5] = CI_BASELINE_IDEOGRAPHIC;
            ciSetFont(ctx, fontAData, 0.2 * height);
            ci.rotate(ctx, 0.2);
            ci.set_color(ctx, CI_FILL_STYLE, 0.0, 0.0, 0.0, 1.0);
            for (index = 0; index < 6; ++index)
            {
                let left = (0.1 + 0.15 * (index)) * width;
                ci.set_text_baseline(ctx, baselines[index]);
                ciFillText(ctx, "Iy", left, 0.5 * height, 1.0e30);
            }
            ci.set_color(ctx, CI_STROKE_STYLE, 1.0, 0.0, 0.0, 0.5);
            ci.set_line_width(ctx, 1.0);
            ci.move_to(ctx, 0.0, 0.5 * height);
            ci.line_to(ctx, width, 0.5 * height);
            ci.move_to(ctx, 0.5 * width, 0.0);
            ci.line_to(ctx, 0.5 * width, height);
            ci.stroke(ctx);
    }

    function wasm_font(ctx, width, height) {
        ci.set_color(ctx, CI_STROKE_STYLE, 1.0, 0.0, 0.0, 1.0);
            ciStrokeText(ctx, "D", 0.8 * width, 0.95 * height, 1.0e30);
            ci.set_color(ctx, CI_FILL_STYLE, 1.0, 0.0, 0.0, 1.0);
            ciFillText(ctx, "D", 0.9 * width, 0.95 * height, 1.0e30);
            ciSetFont(ctx, 0, 0, 0.1 * height);
            ci.set_color(ctx, CI_FILL_STYLE, 0.0, 0.0, 0.0, 1.0);
            ciSetFont(ctx, fontAData, 0.2 * height);
            ciFillText(ctx, "CE\xc3\x8d\xf4\x8f\xbf\xbd\xf0I", 0.0, 0.20 * height, 1.0e30);
            ciSetFont(ctx, 0, 0, 0.1 * height);
            ciFillText(ctx, "CE\xc3\x8d\xf4\x8f\xbf\xbd\xf0I", 0.65 * width, 0.20 * height, 1.0e30);
            ciSetFont(ctx, fontBData, 0.2 * height);
            ciFillText(ctx, "CE\xc3\x8d\xf4\x8f\xbf\xbd\xf0I", 0.0, 0.45 * height, 1.0e30);
            ciSetFont(ctx, fontCData, 0.2 * height);
            ciFillText(ctx, "CE\xc3\x8d\xf4\x8f\xbf\xbd\xf0I", 0.0, 0.70 * height, 1.0e30);
            ci.set_color(ctx, CI_FILL_STYLE, 1.0, 0.0, 0.0, 1.0);
            ciSetFont(ctx, fontDData, 0.2 * height);
            ciFillText(ctx, "D", 0.1 * width, 0.95 * height, 1.0e30);
            ciSetFont(ctx, fontEData, 0.2 * height);
            ciFillText(ctx, "D", 0.2 * width, 0.95 * height, 1.0e30);
            ciSetFont(ctx, fontFData, 0.2 * height);
            ciFillText(ctx, "D", 0.3 * width, 0.95 * height, 1.0e30);
            ciSetFont(ctx, fontGData, 0.2 * height);
            ciFillText(ctx, "D", 0.4 * width, 0.95 * height, 1.0e30);
    }

    function wasm_fill_text(ctx, width, height) {
        ci.set_linear_gradient(ctx, CI_FILL_STYLE, 0.4 * width, 0.0, 0.6 * width, 0.0);
            ci.add_color_stop(ctx, CI_FILL_STYLE, 0.00, 0.0, 0.00, 1.0, 1.0);
            ci.add_color_stop(ctx, CI_FILL_STYLE, 0.45, 0.0, 0.25, 0.5, 1.0);
            ci.add_color_stop(ctx, CI_FILL_STYLE, 0.50, 1.0, 0.00, 0.0, 1.0);
            ci.add_color_stop(ctx, CI_FILL_STYLE, 0.55, 0.0, 0.25, 0.5, 1.0);
            ci.add_color_stop(ctx, CI_FILL_STYLE, 1.00, 0.0, 0.50, 0.0, 1.0);
            ciSetFont(ctx, fontAData, 0.3 * height);
            ci.rotate(ctx, 0.2);
            ci.set_shadow_offset_x(ctx, 2.0);
            ci.set_shadow_offset_y(ctx, 2.0);
            ci.set_shadow_blur(ctx, 4.0);
            ci.set_shadow_color(ctx, 0.0, 0.0, 0.0, 0.75);
            ci.move_to(ctx, 0.0, 0.2 * height);
            ciFillText(ctx, "Canvas", 0.1 * width, 0.2 * height, 1.0e30);
            ci.line_to(ctx, width, 0.2 * height);
            ciFillText(ctx, "Ity\n*", 0.2 * width, 0.5 * height, width);
            ci.move_to(ctx, 0.0, 0.5 * height);
            ciFillText(ctx, "*Canvas\fIty*", 0.2 * width, 0.8 * height, 0.7 * width);
            ci.set_color(ctx, CI_FILL_STYLE, 1.0, 0.0, 0.0, 1.0);
            ciFillText(ctx, "****", 0.1 * width, 0.35 * height, 0.0);
            ci.line_to(ctx, width, 0.5 * height);
            ci.set_shadow_color(ctx, 0.0, 0.0, 0.0, 0.0);
            ci.set_color(ctx, CI_STROKE_STYLE, 1.0, 0.0, 0.0, 1.0);
            ci.set_line_width(ctx, 2.0);
            ci.stroke(ctx);
    }

    function wasm_stroke_text(ctx, width, height) {
        let segments = new Float32Array(2);
            ci.set_color(ctx, CI_STROKE_STYLE, 0.0, 0.0, 0.0, 1.0);
            ciSetFont(ctx, fontAData, 0.3 * height);
            ci.rotate(ctx, 0.2);
            ci.set_line_width(ctx, 2.0);
            segments[0] = 8.0; segments[1] = 2.0;
            ciSetLineDash(ctx, Array.from(segments).slice(0, 2));
            ci.move_to(ctx, 0.0, 0.2 * height);
            ciStrokeText(ctx, "Canvas", 0.1 * width, 0.2 * height, 1.0e30);
            ci.line_to(ctx, width, 0.2 * height);
            ciStrokeText(ctx, "Ity\n*", 0.2 * width, 0.5 * height, width);
            ci.move_to(ctx, 0.0, 0.5 * height);
            ciStrokeText(ctx, "*Canvas\fIty*", 0.2 * width, 0.8 * height, 0.7 * width);
            ci.set_color(ctx, CI_STROKE_STYLE, 1.0, 0.0, 0.0, 1.0);
            ciStrokeText(ctx, "****", 0.1 * width, 0.35 * height, 0.0);
            ci.line_to(ctx, width, 0.5 * height);
            ciSetLineDash(ctx, []);
            ci.stroke(ctx);
    }

    function wasm_measure_text(ctx, width, height) {
        let place;
            ci.set_color(ctx, CI_FILL_STYLE, 0.0, 0.0, 0.0, 1.0);
            place = 0.1 * width;
            place += ciMeasureText(ctx, "C");
            ciSetFont(ctx, fontAData, 0.3 * height);
            ci.rotate(ctx, 0.5);
            ci.scale(ctx, 1.15, 1.0);
            ciFillText(ctx, "C", place, 0.2 * height, 1.0e30);
            place += ciMeasureText(ctx, "C");
            ciFillText(ctx, "a", place, 0.25 * height, 1.0e30);
            place += ciMeasureText(ctx, "a");
            ciFillText(ctx, "nv", place, 0.2 * height, 1.0e30);
            place += ciMeasureText(ctx, "nv");
            ciFillText(ctx, "a", place, 0.15 * height, 1.0e30);
            place += ciMeasureText(ctx, "a");
            ciFillText(ctx, "s", place, 0.2 * height, 1.0e30);
    }

    function wasm_text_kerning(ctx, width, height) {
        // Kerning test: requires font binary manipulation.
        // These tests build custom font binaries with kern/GPOS tables.
        // Showing placeholder - full implementation requires font builder in JS.
        ci.set_color(ctx, CI_FILL_STYLE, 0.8, 0.8, 0.8, 1.0);
        ci.fill_rectangle(ctx, 0, 0, width, height);
    }

    function wasm_text_kerning_measure(ctx, width, height) {
        // Kerning test: requires font binary manipulation.
        // These tests build custom font binaries with kern/GPOS tables.
        // Showing placeholder - full implementation requires font builder in JS.
        ci.set_color(ctx, CI_FILL_STYLE, 0.8, 0.8, 0.8, 1.0);
        ci.fill_rectangle(ctx, 0, 0, width, height);
    }

    function wasm_text_kerning_aat(ctx, width, height) {
        // Kerning test: requires font binary manipulation.
        // These tests build custom font binaries with kern/GPOS tables.
        // Showing placeholder - full implementation requires font builder in JS.
        ci.set_color(ctx, CI_FILL_STYLE, 0.8, 0.8, 0.8, 1.0);
        ci.fill_rectangle(ctx, 0, 0, width, height);
    }

    function wasm_text_kerning_aat_measure(ctx, width, height) {
        // Kerning test: requires font binary manipulation.
        // These tests build custom font binaries with kern/GPOS tables.
        // Showing placeholder - full implementation requires font builder in JS.
        ci.set_color(ctx, CI_FILL_STYLE, 0.8, 0.8, 0.8, 1.0);
        ci.fill_rectangle(ctx, 0, 0, width, height);
    }

    function wasm_text_kerning_gpos_fmt1(ctx, width, height) {
        // Kerning test: requires font binary manipulation.
        // These tests build custom font binaries with kern/GPOS tables.
        // Showing placeholder - full implementation requires font builder in JS.
        ci.set_color(ctx, CI_FILL_STYLE, 0.8, 0.8, 0.8, 1.0);
        ci.fill_rectangle(ctx, 0, 0, width, height);
    }

    function wasm_text_kerning_gpos_fmt2(ctx, width, height) {
        // Kerning test: requires font binary manipulation.
        // These tests build custom font binaries with kern/GPOS tables.
        // Showing placeholder - full implementation requires font builder in JS.
        ci.set_color(ctx, CI_FILL_STYLE, 0.8, 0.8, 0.8, 1.0);
        ci.fill_rectangle(ctx, 0, 0, width, height);
    }

    function wasm_draw_image(ctx, width, height) {
        let checker = new Uint8Array(1024);
            let index;
            let row; let column;
            let pixel = new Uint8Array(4);
            for (index = 0; index < 1024; ++index)
                checker[index] = (
                    (((index >> 2 & 1) ^ (index >> 6 & 1)) |
                     ((index & 3) == 3)) * 255);
            ciDrawImage(ctx, checker, 16, 16, 64,
                                 0.0, 0.0, width * 0.75, height * 0.75);
            for (row = 0.0; row < 4.0; row += 1.0)
                for (column = 0.0; column < 4.0; column += 1.0)
                    ciDrawImage(ctx, checker, 16, 16, 64,
                                         column * 17.25, row * 17.25, 16.0, 16.0);
            ciDrawImage(ctx, checker, 16, 16, 64, 128.0, 0.0, 32.0, 8.0);
            ciDrawImage(ctx, checker, 16, 16, 64, 128.0, 48.0, 32.0, -32.0);
            ciDrawImage(ctx, checker, 16, 16, 64, 200.0, 16.0, -32.0, 32.0);
            ciDrawImage(ctx, checker, 16, 16, 64, 128.0, 64.0, 32.0, 0.0);
            ciDrawImage(ctx, 0, 16, 16, 64, 200.0, 64.0, 32.0, 32.0);
            pixel[0] = 0; pixel[1] = 255; pixel[2] = 0; pixel[3] = 255;
            ciDrawImage(ctx, pixel, 1, 1, 4,
                                 width * 0.875, height * 0.25, 1.0, 1.0);
            ciDrawImage(ctx, pixel, 1, 1, 4,
                                 width * 0.875, height * 0.5, 16.0, 16.0);
            ci.rotate(ctx, 0.2);
            ci.set_global_composite_operation(ctx, CI_LIGHTER);
            ci.set_global_alpha(ctx, 1.0);
            ciDrawImage(ctx, checker, 16, 16, 64,
                                 0.25 * width, 0.25 * height,
                                 0.5 * width, 0.5 * height);
    }

    function wasm_draw_image_matted(ctx, width, height) {
        let checker = new Uint8Array(36);
            let y_pos; let size_y; let x_pos; let size_x;
            let step_y; let step_x;
            ci.set_color(ctx, CI_FILL_STYLE, 0.0, 1.0, 0.0, 0.0);
            ci.fill_rectangle(ctx, 0.0, 0.0, width, height);
            checker[0]=0; checker[1]=0; checker[2]=255; checker[3]=255;
            checker[4]=255; checker[5]=0; checker[6]=0; checker[7]=0;
            checker[8]=0; checker[9]=0; checker[10]=255; checker[11]=255;
            checker[12]=255; checker[13]=0; checker[14]=0; checker[15]=0;
            checker[16]=0; checker[17]=0; checker[18]=255; checker[19]=255;
            checker[20]=255; checker[21]=0; checker[22]=0; checker[23]=0;
            checker[24]=0; checker[25]=0; checker[26]=255; checker[27]=255;
            checker[28]=255; checker[29]=0; checker[30]=0; checker[31]=0;
            checker[32]=0; checker[33]=0; checker[34]=255; checker[35]=255;
            y_pos = 0.5;
            size_y = 3.0;
            for (step_y = 0; step_y < 20 && y_pos < height; ++step_y)
            {
                x_pos = 0.5;
                size_x = 3.0;
                for (step_x = 0; step_x < 20 && x_pos < width; ++step_x)
                {
                    ciDrawImage(ctx, checker, 3, 3, 12, x_pos, y_pos, size_x, size_y);
                    x_pos += size_x + 5.0;
                    size_x *= 1.5;
                }
                y_pos += size_y + 5.0;
                size_y *= 1.5;
            }
    }

    function wasm_get_image_data(ctx, width, height) {
        let index;
            let data = new Uint8Array(4939);
            let hash;
            let expected;
            for (index = 0; index < 100; ++index)
            {
                ci.set_color(ctx, CI_FILL_STYLE,
                                    (Math.trunc(index / 2) % 2),
                                    (Math.trunc(index / 4) % 2),
                                    (Math.trunc(index / 8) % 2),
                                    (Math.trunc(index / 16) % 2));
                ci.fill_rectangle(ctx, 3.0 * (index % 10),
                                         3.0 * Math.trunc(index / 10),
                                         3.0, 3.0);
            }
            data[0] = 150;
            for (index = 1; index < 4939; ++index)
                data[index] = (
                    (data[index - 1] * 137 + 53) & 255);
            ciGetImageData(ctx, data.subarray(2), 35, 35, 141, -10, -10);
            hash = 0;
            for (index = 0; index < 4939; ++index)
                hash = (((hash & 0x1ffff) << 15) | (hash >>> 17)) ^ data[index];
            expected = 0xf53f9792;
            ci.set_color(ctx, CI_FILL_STYLE, ((hash >>> 0) != expected) ? 1.0 : 0.0, ((hash >>> 0) == expected) ? 1.0 : 0.0, 0.0, 1.0);
            ci.fill_rectangle(ctx, 30.0, 0.0, width, 30.0);
            ci.set_linear_gradient(ctx, CI_FILL_STYLE, 0.0, 0.0, width, 0.0);
            ci.add_color_stop(ctx, CI_FILL_STYLE, 0.0, 1.0, 0.0, 0.0, 1.0);
            ci.add_color_stop(ctx, CI_FILL_STYLE, 1.0, 0.0, 1.0, 0.0, 1.0);
            ci.fill_rectangle(ctx, 0.0, 0.45 * height, width, 0.1 * height);
            ciGetImageData(ctx, 0, 32, 32, 128, 0, 0);
    }

    function wasm_put_image_data(ctx, width, height) {
        let checker = new Uint8Array(2052);
            let index; let iy; let ix;
            for (index = 0; index < 2048; ++index)
                checker[index + 2] = (
                    ((((index >> 2 & 1) ^ (index >> 7 & 1)) |
                      ((index & 3) == 3)) &
                     (index >> 10 & 1)) * 255);
            checker[0] = 157;
            checker[1] = 157;
            checker[2050] = 157;
            checker[2051] = 157;
            ci.set_color(ctx, CI_FILL_STYLE, 0.4, 0.05, 0.2, 1.0);
            ci.fill_rectangle(ctx, 0.0, 0.0, 0.25 * width, 0.25 * height);
            ci.set_global_alpha(ctx, 0.5);
            ci.set_global_composite_operation(ctx, CI_LIGHTER);
            ci.rotate(ctx, 0.2);
            for (iy = -10; iy < (height); iy += 29)
                for (ix = -10; ix < (width); ix += 29)
                    ciPutImageData(ctx, checker.subarray(6), 16, 16, 128, ix, iy);
            ciPutImageData(ctx, 0, 32, 32, 128, 0, 0);
    }

    function wasm_save_restore(ctx, width, height) {
        ci.rectangle(ctx, width * 0.25, height * 0.25,
                                width * 0.25, height * 0.25);
            ci.set_color(ctx, CI_STROKE_STYLE, 0.0, 0.0, 1.0, 1.0);
            ci.set_line_width(ctx, 8.0);
            ci.save(ctx);
            ci.clip(ctx);
            ci.begin_path(ctx);
            ci.rectangle(ctx, width * 0.25, height * 0.25,
                                width * 0.5, height * 0.5);
            ci.set_color(ctx, CI_STROKE_STYLE, 1.0, 0.0, 0.0, 1.0);
            ci.set_line_width(ctx, 1.0);
            ci.restore(ctx);
            ci.restore(ctx);
            ci.stroke(ctx);
            ci.save(ctx);
            ci.save(ctx);
    }

    function wasm_example_button(ctx, width, height) {
        let left; let right; let top; let bottom; let mid_x; let mid_y;
            left = Math.floor((0.25 * width) + 0.5);
            right = Math.floor((0.75 * width) + 0.5);
            top = Math.floor((0.375 * height) + 0.5);
            bottom = Math.floor((0.625 * height) + 0.5);
            mid_x = (left + right) * 0.5;
            mid_y = (top + bottom) * 0.5;
            ci.set_shadow_offset_x(ctx, 3.0);
            ci.set_shadow_offset_y(ctx, 3.0);
            ci.set_shadow_blur(ctx, 3.0);
            ci.set_shadow_color(ctx, 0.0, 0.0, 0.0, 0.5);
            ci.set_linear_gradient(ctx, CI_FILL_STYLE, 0.0, top, 0.0, bottom);
            ci.add_color_stop(ctx, CI_FILL_STYLE, 0.0, 0.3, 0.3, 0.3, 1.0);
            ci.add_color_stop(ctx, CI_FILL_STYLE, 1.0, 0.2, 0.2, 0.2, 1.0);
            ci.move_to(ctx, left + 0.5, mid_y);
            ci.arc_to(ctx, left + 0.5, top + 0.5, mid_x, top + 0.5, 4.0);
            ci.arc_to(ctx, right - 0.5, top + 0.5, right - 0.5, mid_y, 4.0);
            ci.arc_to(ctx, right - 0.5, bottom - 0.5, mid_x, bottom - 0.5, 4.0);
            ci.arc_to(ctx, left + 0.5, bottom - 0.5, left + 0.5, mid_y, 4.0);
            ci.close_path(ctx);
            ci.fill(ctx);
            ci.set_shadow_color(ctx, 0.0, 0.0, 0.0, 0.0);
            ciSetFont(ctx, fontAData, 0.075 * height);
            ci.set_text_align(ctx, CI_ALIGN_CENTER);
            ci.set_text_baseline(ctx, CI_BASELINE_MIDDLE);
            ci.set_color(ctx, CI_FILL_STYLE, 0.8, 0.8, 0.8, 1.0);
            ciFillText(ctx, "* Cats", 0.5 * width, 0.5 * height, 1.0e30);
            ci.set_color(ctx, CI_FILL_STYLE, 0.4, 0.4, 0.4, 1.0);
            ci.fill_rectangle(ctx, left + 4.0, top + 1.0, right - left - 8.0, 1.0);
            ci.set_color(ctx, CI_STROKE_STYLE, 0.1, 0.1, 0.1, 1.0);
            ci.stroke(ctx);
    }

    function wasm_example_smiley(ctx, width, height) {
        let center_x = 0.5 * width;
            let center_y = 0.5 * height;
            let radius = Math.min(width, height) * 0.4;
            ci.set_radial_gradient(ctx, CI_FILL_STYLE,
                                          center_x, center_y, 0.0,
                                          center_x, center_y, radius);
            ci.add_color_stop(ctx, CI_FILL_STYLE, 0.0, 1.0, 0.9, 0.2, 1.0);
            ci.add_color_stop(ctx, CI_FILL_STYLE, 0.95, 0.95, 0.65, 0.15, 1.0);
            ci.add_color_stop(ctx, CI_FILL_STYLE, 1.0, 0.9, 0.55, 0.0, 1.0);
            ci.arc(ctx, center_x, center_y, radius, 0.0, 6.28318531, 0);
            ci.fill(ctx);
            ci.set_linear_gradient(ctx, CI_FILL_STYLE,
                                          center_x, center_y - 0.95 * radius,
                                          center_x, center_y);
            ci.add_color_stop(ctx, CI_FILL_STYLE, 0.0, 1.0, 1.0, 1.0, 0.5);
            ci.add_color_stop(ctx, CI_FILL_STYLE, 1.0, 1.0, 1.0, 1.0, 0.0);
            ci.begin_path(ctx);
            ci.arc(ctx, center_x, center_y - 0.15 * radius, 0.8 * radius,
                          0.0, 6.28318531, 0);
            ci.fill(ctx);
            ci.set_color(ctx, CI_STROKE_STYLE, 0.0, 0.0, 0.0, 0.95);
            ci.set_line_width(ctx, 0.2 * radius);
            ci.set_line_cap(ctx, CI_CAP_CIRCLE);
            ci.begin_path(ctx);
            ci.move_to(ctx, center_x - 0.2 * radius, center_y - 0.5 * radius);
            ci.line_to(ctx, center_x - 0.2 * radius, center_y - 0.2 * radius);
            ci.move_to(ctx, center_x + 0.2 * radius, center_y - 0.5 * radius);
            ci.line_to(ctx, center_x + 0.2 * radius, center_y - 0.2 * radius);
            ci.stroke(ctx);
            ci.set_color(ctx, CI_FILL_STYLE, 0.0, 0.0, 0.0, 0.95);
            ci.begin_path(ctx);
            ci.move_to(ctx, center_x - 0.6 * radius, center_y + 0.1 * radius);
            ci.bezier_curve_to(ctx, center_x - 0.3 * radius, center_y + 0.8 * radius,
                                      center_x + 0.3 * radius, center_y + 0.8 * radius,
                                      center_x + 0.6 * radius, center_y + 0.1 * radius);
            ci.bezier_curve_to(ctx, center_x + 0.3 * radius, center_y + 0.3 * radius,
                                      center_x - 0.3 * radius, center_y + 0.3 * radius,
                                      center_x - 0.6 * radius, center_y + 0.1 * radius);
            ci.fill(ctx);
    }

    function wasm_example_knot(ctx, width, height) {
        let points = Array.from({length:6}, () => new Float32Array(8));
            let index;
            points[0][0]=0.0; points[0][1]=-1.0; points[0][2]=0.0; points[0][3]=0.0;
            points[0][4]=0.0; points[0][5]=0.0; points[0][6]=0.0; points[0][7]=1.0;
            points[1][0]=-1.0; points[1][1]=-1.0; points[1][2]=-1.0; points[1][3]=0.0;
            points[1][4]=1.0; points[1][5]=0.0; points[1][6]=1.0; points[1][7]=1.0;
            points[2][0]=2.0; points[2][1]=1.0; points[2][2]=2.0; points[2][3]=-2.0;
            points[2][4]=-1.0; points[2][5]=-2.0; points[2][6]=-1.0; points[2][7]=-1.0;
            points[3][0]=-2.0; points[3][1]=-1.0; points[3][2]=-2.0; points[3][3]=2.0;
            points[3][4]=1.0; points[3][5]=2.0; points[3][6]=1.0; points[3][7]=1.0;
            points[4][0]=-2.0; points[4][1]=-1.0; points[4][2]=-2.0; points[4][3]=-3.0;
            points[4][4]=0.0; points[4][5]=-3.0; points[4][6]=0.0; points[4][7]=-1.0;
            points[5][0]=2.0; points[5][1]=1.0; points[5][2]=2.0; points[5][3]=3.0;
            points[5][4]=0.0; points[5][5]=3.0; points[5][6]=0.0; points[5][7]=1.0;
            ci.translate(ctx, width * 0.5, height * 0.5);
            ci.scale(ctx, width * 0.17, height * 0.17);
            ci.rotate(ctx, -15.0 * 3.14159265 / 180.0);
            for (index = 0; index < 6; ++index)
            {
                ci.begin_path(ctx);
                ci.move_to(ctx,
                    1.01 * points[index][0] - 0.01 * points[index][2],
                    1.01 * points[index][1] - 0.01 * points[index][3]);
                ci.line_to(ctx, points[index][0], points[index][1]);
                ci.bezier_curve_to(ctx, points[index][2], points[index][3],
                                          points[index][4], points[index][5],
                                          points[index][6], points[index][7]);
                ci.line_to(ctx,
                    -0.01 * points[index][4] + 1.01 * points[index][6],
                    -0.01 * points[index][5] + 1.01 * points[index][7]);
                ci.set_color(ctx, CI_STROKE_STYLE, 0.0, 0.0, 0.0, 1.0);
                ci.set_line_width(ctx, 0.75);
                ci.set_line_cap(ctx, CI_CAP_BUTT);
                ci.stroke(ctx);
                ci.set_radial_gradient(ctx, CI_STROKE_STYLE,
                                              0.0, 0.0, 0.0,
                                              0.0, 0.0, 3.0);
                ci.add_color_stop(ctx, CI_STROKE_STYLE, 0.0, 0.8, 1.0, 0.6, 1.0);
                ci.add_color_stop(ctx, CI_STROKE_STYLE, 1.0, 0.1, 0.5, 0.1, 1.0);
                ci.set_line_width(ctx, 0.5);
                ci.set_line_cap(ctx, CI_CAP_CIRCLE);
                ci.stroke(ctx);
            }
    }

    function wasm_example_icon(ctx, width, height) {
        ci.set_shadow_color(ctx, 0.0, 0.0, 0.0, 1.0);
            ci.set_shadow_offset_x(ctx, width / 64.0);
            ci.set_shadow_offset_y(ctx, height / 64.0);
            ci.set_shadow_blur(ctx, Math.min(width, height) / 32.0);
            ci.scale(ctx, width / 32.0, height / 32.0);
            ci.set_color(ctx, CI_FILL_STYLE, 0.4, 0.05, 0.2, 1.0);
            ci.move_to(ctx, 15.5, 1.0);
            ci.arc_to(ctx, 30.0, 1.0, 30.0, 15.5, 6.0);
            ci.arc_to(ctx, 30.0, 30.0, 15.5, 30.0, 6.0);
            ci.arc_to(ctx, 1.0, 30.0, 1.0, 15.5, 6.0);
            ci.arc_to(ctx, 1.0, 1.0, 15.5, 1.0, 6.0);
            ci.fill(ctx);
            ci.set_color(ctx, CI_STROKE_STYLE, 0.5, 0.5, 0.5, 1.0);
            ci.begin_path(ctx);
            ci.move_to(ctx, 11.0, 16.0);
            ci.line_to(ctx, 27.0, 16.0);
            ci.move_to(ctx, 2.0, 23.0);
            ci.line_to(ctx, 29.0, 23.0);
            ci.stroke(ctx);
            ci.set_color(ctx, CI_STROKE_STYLE, 0.75, 0.75, 0.75, 1.0);
            ci.begin_path(ctx);
            ci.arc(ctx, 25.0, 22.0, 0.5, 0.0, 6.28318531, 0);
            ci.move_to(ctx, 19.0, 6.0); ci.line_to(ctx, 18.5, 8.0);
            ci.move_to(ctx, 20.0, 6.0); ci.line_to(ctx, 20.0, 8.0);
            ci.move_to(ctx, 21.0, 6.0); ci.line_to(ctx, 21.5, 8.0);
            ci.move_to(ctx, 17.0, 14.0); ci.line_to(ctx, 16.0, 18.0);
            ci.move_to(ctx, 20.0, 14.0); ci.line_to(ctx, 20.0, 18.0);
            ci.move_to(ctx, 23.0, 14.0); ci.line_to(ctx, 24.0, 18.0);
            ci.move_to(ctx, 18.0, 9.0); ci.line_to(ctx, 22.0, 9.0);
            ci.move_to(ctx, 18.0, 13.0); ci.line_to(ctx, 22.0, 13.0);
            ci.rectangle(ctx, 16.0, 8.0, 8.0, 6.0);
            ci.stroke(ctx);
            ci.set_color(ctx, CI_STROKE_STYLE, 1.0, 1.0, 1.0, 1.0);
            ci.begin_path(ctx);
            ci.arc(ctx, 19.0, 12.0, 9.0, 0.0, 6.28318531, 0);
            ci.move_to(ctx, 12.3, 17.3); ci.line_to(ctx, 3.3, 26.3);
            ci.move_to(ctx, 13.0, 18.0); ci.line_to(ctx, 4.0, 27.0);
            ci.move_to(ctx, 13.7, 18.7); ci.line_to(ctx, 4.7, 27.7);
            ci.stroke(ctx);
    }

    function wasm_example_illusion(ctx, width, height) {
        let spot;
            ci.set_color(ctx, CI_FILL_STYLE, 0.0, 0.4, 1.0, 1.0);
            ci.fill_rectangle(ctx, 0.0, 0.0, width, height);
            ci.set_color(ctx, CI_FILL_STYLE, 0.8, 0.8, 0.0, 1.0);
            ci.set_line_width(ctx, 0.4);
            for (spot = 0.0; spot < 240.0; spot += 1.0)
            {
                let angle = (((spot * 0.61803398875)) % (1.0)) * 6.28318531;
                let radius = spot / 240.0 * 0.5 * Math.sqrt((width*width + height*height));
                let size = Math.min(width, height) * Math.sqrt(spot) / 240.0;
                ci.set_transform(ctx, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0);
                ci.translate(ctx, 0.5 * width + radius * Math.cos(angle),
                                    0.5 * height + radius * Math.sin(angle));
                ci.rotate(ctx, angle - 1.3);
                ci.scale(ctx, 0.8 * size, 0.6 * size);
                ci.rotate(ctx, 1.3);
                ci.begin_path(ctx);
                ci.arc(ctx, 0.0, 0.0, 1.0, 0.0, 6.28318531, 0);
                ci.fill(ctx);
                ci.begin_path(ctx);
                ci.arc(ctx, 0.0, 0.0, 1.0, 0.0, 3.14159265, 0);
                ci.set_color(ctx, CI_STROKE_STYLE, 1.0, 1.0, 1.0, 1.0);
                ci.stroke(ctx);
                ci.begin_path(ctx);
                ci.arc(ctx, 0.0, 0.0, 1.0, 3.14159265, 6.28318531, 0);
                ci.set_color(ctx, CI_STROKE_STYLE, 0.0, 0.0, 0.0, 1.0);
                ci.stroke(ctx);
            }
    }

    function wasm_example_star(ctx, width, height) {
        let segments = new Float32Array(8);
            ci.scale(ctx, width / 256.0, height / 256.0);
            ci.move_to(ctx, 128.0, 28.0);
            ci.line_to(ctx, 157.0, 87.0);
            ci.line_to(ctx, 223.0, 97.0);
            ci.line_to(ctx, 175.0, 143.0);
            ci.line_to(ctx, 186.0, 208.0);
            ci.line_to(ctx, 128.0, 178.0);
            ci.line_to(ctx, 69.0, 208.0);
            ci.line_to(ctx, 80.0, 143.0);
            ci.line_to(ctx, 32.0, 97.0);
            ci.line_to(ctx, 98.0, 87.0);
            ci.close_path(ctx);
            ci.set_shadow_blur(ctx, 8.0);
            ci.set_shadow_offset_y(ctx, 4.0);
            ci.set_shadow_color(ctx, 0.0, 0.0, 0.0, 0.5);
            ci.set_color(ctx, CI_FILL_STYLE, 1.0, 0.9, 0.2, 1.0);
            ci.fill(ctx);
            ci.set_line_join(ctx, CI_JOIN_ROUNDED);
            ci.set_line_width(ctx, 12.0);
            ci.set_color(ctx, CI_STROKE_STYLE, 0.9, 0.0, 0.5, 1.0);
            ci.stroke(ctx);
            segments[0]=21.0; segments[1]=9.0; segments[2]=1.0; segments[3]=9.0;
            segments[4]=7.0; segments[5]=9.0; segments[6]=1.0; segments[7]=9.0;
            ciSetLineDash(ctx, Array.from(segments).slice(0, 8));
            ci.set_line_dash_offset(ctx, 10.0);
            ci.set_line_cap(ctx, CI_CAP_CIRCLE);
            ci.set_line_width(ctx, 6.0);
            ci.set_color(ctx, CI_STROKE_STYLE, 0.95, 0.65, 0.15, 1.0);
            ci.stroke(ctx);
            ci.set_shadow_color(ctx, 0.0, 0.0, 0.0, 0.0);
            ci.set_linear_gradient(ctx, CI_FILL_STYLE, 64.0, 0.0, 192.0, 256.0);
            ci.add_color_stop(ctx, CI_FILL_STYLE, 0.30, 1.0, 1.0, 1.0, 0.0);
            ci.add_color_stop(ctx, CI_FILL_STYLE, 0.35, 1.0, 1.0, 1.0, 0.8);
            ci.add_color_stop(ctx, CI_FILL_STYLE, 0.45, 1.0, 1.0, 1.0, 0.8);
            ci.add_color_stop(ctx, CI_FILL_STYLE, 0.50, 1.0, 1.0, 1.0, 0.0);
            ci.set_global_composite_operation(ctx, CI_SOURCE_ATOP);
            ci.fill_rectangle(ctx, 0.0, 0.0, 256.0, 256.0);
    }

    function wasm_example_neon(ctx, width, height) {
        ci.scale(ctx, width / 256.0, height / 256.0);
            ci.set_color(ctx, CI_FILL_STYLE, 0.0, 0.0625, 0.125, 1.0);
            ci.fill_rectangle(ctx, 0.0, 0.0, 256.0, 256.0);
            ci.move_to(ctx, 45.5, 96.2);
            ci.bezier_curve_to(ctx, 45.5, 96.2, 31.3, 106.2, 31.5, 113.1);
            ci.bezier_curve_to(ctx, 31.7, 119.5, 50.6, 104.8, 50.6, 93.9);
            ci.bezier_curve_to(ctx, 50.6, 91.1, 46.6, 89.1, 43.3, 89.4);
            ci.bezier_curve_to(ctx, 27.5, 90.6, 8.5, 108.2, 8.8, 121.8);
            ci.bezier_curve_to(ctx, 9.1, 133.1, 21.3, 136.6, 29.8, 136.3);
            ci.bezier_curve_to(ctx, 52.4, 135.5, 62.3, 115.6, 62.3, 115.6);
            ci.move_to(ctx, 81.0, 120.2);
            ci.bezier_curve_to(ctx, 81.0, 120.2, 60.2, 123.0, 59.7, 130.8);
            ci.bezier_curve_to(ctx, 59.2, 140.6, 73.8, 136.4, 78.3, 125.3);
            ci.move_to(ctx, 80.7, 130.5);
            ci.bezier_curve_to(ctx, 79.5, 132.4, 80.9, 135.0, 83.4, 135.0);
            ci.bezier_curve_to(ctx, 95.8, 135.6, 99.3, 122.5, 111.4, 121.6);
            ci.bezier_curve_to(ctx, 112.8, 121.5, 114.0, 123.0, 114.0, 124.3);
            ci.bezier_curve_to(ctx, 113.9, 126.1, 106.7, 133.9, 106.7, 133.9);
            ci.move_to(ctx, 118.5, 122.9);
            ci.bezier_curve_to(ctx, 118.5, 122.9, 122.1, 118.8, 126.1, 122.0);
            ci.bezier_curve_to(ctx, 131.4, 126.4, 118.7, 131.6, 124.3, 134.7);
            ci.bezier_curve_to(ctx, 130.0, 137.8, 150.0, 116.5, 156.0, 120.2);
            ci.bezier_curve_to(ctx, 160.2, 122.8, 149.0, 133.5, 155.6, 133.6);
            ci.bezier_curve_to(ctx, 162.0, 133.4, 173.8, 118.3, 168.0, 117.8);
            ci.move_to(ctx, 173.1, 123.2);
            ci.bezier_curve_to(ctx, 177.8, 124.8, 182.8, 123.2, 187.0, 119.7);
            ci.move_to(ctx, 206.1, 118.6);
            ci.bezier_curve_to(ctx, 206.1, 118.6, 185.3, 121.3, 185.1, 129.1);
            ci.bezier_curve_to(ctx, 185.0, 138.7, 199.9, 135.4, 203.6, 123.6);
            ci.move_to(ctx, 205.6, 129.9);
            ci.bezier_curve_to(ctx, 204.4, 131.8, 205.8, 134.4, 208.3, 134.4);
            ci.bezier_curve_to(ctx, 220.3, 134.4, 246.6, 117.1, 246.6, 117.1);
            ci.move_to(ctx, 247.0, 122.4);
            ci.bezier_curve_to(ctx, 245.9, 128.5, 243.9, 139.7, 231.2, 131.5);
            ci.set_line_cap(ctx, CI_CAP_CIRCLE);
            ci.set_shadow_color(ctx, 1.0, 0.5, 0.0, 1.0);
            ci.set_shadow_blur(ctx, 20.0);
            ci.set_line_width(ctx, 4.0);
            ci.set_color(ctx, CI_STROKE_STYLE, 1.0, 0.5, 0.0, 1.0);
            ci.stroke(ctx);
            ci.set_shadow_blur(ctx, 5.0);
            ci.set_line_width(ctx, 3.0);
            ci.set_color(ctx, CI_STROKE_STYLE, 1.0, 0.625, 0.0, 1.0);
            ci.stroke(ctx);
    }

    // =====================================================================
    // Run all tests
    // =====================================================================
    let passed = 0, failed = 0;

    if (runTest("scale_uniform", 256, 256, wasm_scale_uniform)) passed++; else failed++;
    if (runTest("scale_non_uniform", 256, 256, wasm_scale_non_uniform)) passed++; else failed++;
    if (runTest("rotate", 256, 256, wasm_rotate)) passed++; else failed++;
    if (runTest("translate", 256, 256, wasm_translate)) passed++; else failed++;
    if (runTest("transform", 256, 256, wasm_transform)) passed++; else failed++;
    if (runTest("transform_fill", 256, 256, wasm_transform_fill)) passed++; else failed++;
    if (runTest("transform_stroke", 256, 256, wasm_transform_stroke)) passed++; else failed++;
    if (runTest("set_transform", 256, 256, wasm_set_transform)) passed++; else failed++;
    if (runTest("global_alpha", 256, 256, wasm_global_alpha)) passed++; else failed++;
    if (runTest("global_composite_operation", 256, 256, wasm_global_composite_operation)) passed++; else failed++;
    if (runTest("shadow_color", 256, 256, wasm_shadow_color)) passed++; else failed++;
    if (runTest("shadow_offset", 256, 256, wasm_shadow_offset)) passed++; else failed++;
    if (runTest("shadow_offset_offscreen", 256, 256, wasm_shadow_offset_offscreen)) passed++; else failed++;
    if (runTest("shadow_blur", 256, 256, wasm_shadow_blur)) passed++; else failed++;
    if (runTest("shadow_blur_offscreen", 256, 256, wasm_shadow_blur_offscreen)) passed++; else failed++;
    if (runTest("shadow_blur_composite", 256, 256, wasm_shadow_blur_composite)) passed++; else failed++;
    if (runTest("line_width", 256, 256, wasm_line_width)) passed++; else failed++;
    if (runTest("line_width_angular", 256, 256, wasm_line_width_angular)) passed++; else failed++;
    if (runTest("line_cap", 256, 256, wasm_line_cap)) passed++; else failed++;
    if (runTest("line_cap_offscreen", 256, 256, wasm_line_cap_offscreen)) passed++; else failed++;
    if (runTest("line_join", 256, 256, wasm_line_join)) passed++; else failed++;
    if (runTest("line_join_offscreen", 256, 256, wasm_line_join_offscreen)) passed++; else failed++;
    if (runTest("miter_limit", 256, 256, wasm_miter_limit)) passed++; else failed++;
    if (runTest("line_dash_offset", 256, 256, wasm_line_dash_offset)) passed++; else failed++;
    if (runTest("line_dash", 256, 256, wasm_line_dash)) passed++; else failed++;
    if (runTest("line_dash_closed", 256, 256, wasm_line_dash_closed)) passed++; else failed++;
    if (runTest("line_dash_overlap", 256, 256, wasm_line_dash_overlap)) passed++; else failed++;
    if (runTest("line_dash_offscreen", 256, 256, wasm_line_dash_offscreen)) passed++; else failed++;
    if (runTest("color", 256, 256, wasm_color)) passed++; else failed++;
    if (runTest("linear_gradient", 256, 256, wasm_linear_gradient)) passed++; else failed++;
    if (runTest("radial_gradient", 256, 256, wasm_radial_gradient)) passed++; else failed++;
    if (runTest("conic_gradient", 256, 256, wasm_conic_gradient)) passed++; else failed++;
    if (runTest("conic_gradient_rect", 256, 256, wasm_conic_gradient_rect)) passed++; else failed++;
    if (runTest("color_stop", 256, 256, wasm_color_stop)) passed++; else failed++;
    if (runTest("pattern", 256, 256, wasm_pattern)) passed++; else failed++;
    if (runTest("begin_path", 256, 256, wasm_begin_path)) passed++; else failed++;
    if (runTest("move_to", 256, 256, wasm_move_to)) passed++; else failed++;
    if (runTest("close_path", 256, 256, wasm_close_path)) passed++; else failed++;
    if (runTest("line_to", 256, 256, wasm_line_to)) passed++; else failed++;
    if (runTest("quadratic_curve_to", 256, 256, wasm_quadratic_curve_to)) passed++; else failed++;
    if (runTest("bezier_curve_to", 256, 256, wasm_bezier_curve_to)) passed++; else failed++;
    if (runTest("arc_to", 256, 256, wasm_arc_to)) passed++; else failed++;
    if (runTest("arc", 256, 256, wasm_arc)) passed++; else failed++;
    if (runTest("ellipse", 256, 256, wasm_ellipse)) passed++; else failed++;
    if (runTest("ellipse_rotated", 256, 256, wasm_ellipse_rotated)) passed++; else failed++;
    if (runTest("rectangle", 256, 256, wasm_rectangle)) passed++; else failed++;
    if (runTest("round_rect", 256, 256, wasm_round_rect)) passed++; else failed++;
    if (runTest("round_rect_clamped", 256, 256, wasm_round_rect_clamped)) passed++; else failed++;
    if (runTest("fill", 256, 256, wasm_fill)) passed++; else failed++;
    if (runTest("fill_rounding", 256, 256, wasm_fill_rounding)) passed++; else failed++;
    if (runTest("fill_converging", 256, 256, wasm_fill_converging)) passed++; else failed++;
    if (runTest("fill_zone_plate", 256, 256, wasm_fill_zone_plate)) passed++; else failed++;
    if (runTest("stroke", 256, 256, wasm_stroke)) passed++; else failed++;
    if (runTest("stroke_wide", 256, 256, wasm_stroke_wide)) passed++; else failed++;
    if (runTest("stroke_inner_join", 256, 256, wasm_stroke_inner_join)) passed++; else failed++;
    if (runTest("stroke_spiral", 256, 256, wasm_stroke_spiral)) passed++; else failed++;
    if (runTest("stroke_long", 256, 256, wasm_stroke_long)) passed++; else failed++;
    if (runTest("clip", 256, 256, wasm_clip)) passed++; else failed++;
    if (runTest("clip_winding", 256, 256, wasm_clip_winding)) passed++; else failed++;
    if (runTest("is_point_in_path", 256, 256, wasm_is_point_in_path)) passed++; else failed++;
    if (runTest("is_point_in_path_offscreen", 256, 256, wasm_is_point_in_path_offscreen)) passed++; else failed++;
    if (runTest("fill_evenodd", 256, 256, wasm_fill_evenodd)) passed++; else failed++;
    if (runTest("fill_evenodd_star", 256, 256, wasm_fill_evenodd_star)) passed++; else failed++;
    if (runTest("clip_evenodd", 256, 256, wasm_clip_evenodd)) passed++; else failed++;
    if (runTest("is_point_in_path_evenodd", 256, 256, wasm_is_point_in_path_evenodd)) passed++; else failed++;
    if (runTest("clear_rectangle", 256, 256, wasm_clear_rectangle)) passed++; else failed++;
    if (runTest("fill_rectangle", 256, 256, wasm_fill_rectangle)) passed++; else failed++;
    if (runTest("stroke_rectangle", 256, 256, wasm_stroke_rectangle)) passed++; else failed++;
    if (runTest("text_align", 256, 256, wasm_text_align)) passed++; else failed++;
    if (runTest("text_baseline", 256, 256, wasm_text_baseline)) passed++; else failed++;
    if (runTest("font", 256, 256, wasm_font)) passed++; else failed++;
    if (runTest("fill_text", 256, 256, wasm_fill_text)) passed++; else failed++;
    if (runTest("stroke_text", 256, 256, wasm_stroke_text)) passed++; else failed++;
    if (runTest("measure_text", 256, 256, wasm_measure_text)) passed++; else failed++;
    if (runTest("text_kerning", 256, 256, wasm_text_kerning)) passed++; else failed++;
    if (runTest("text_kerning_measure", 256, 256, wasm_text_kerning_measure)) passed++; else failed++;
    if (runTest("text_kerning_aat", 256, 256, wasm_text_kerning_aat)) passed++; else failed++;
    if (runTest("text_kerning_aat_measure", 256, 256, wasm_text_kerning_aat_measure)) passed++; else failed++;
    if (runTest("text_kerning_gpos_fmt1", 256, 256, wasm_text_kerning_gpos_fmt1)) passed++; else failed++;
    if (runTest("text_kerning_gpos_fmt2", 256, 256, wasm_text_kerning_gpos_fmt2)) passed++; else failed++;
    if (runTest("draw_image", 256, 256, wasm_draw_image)) passed++; else failed++;
    if (runTest("draw_image_matted", 256, 256, wasm_draw_image_matted)) passed++; else failed++;
    if (runTest("get_image_data", 256, 256, wasm_get_image_data)) passed++; else failed++;
    if (runTest("put_image_data", 256, 256, wasm_put_image_data)) passed++; else failed++;
    if (runTest("save_restore", 256, 256, wasm_save_restore)) passed++; else failed++;
    if (runTest("example_button", 256, 256, wasm_example_button)) passed++; else failed++;
    if (runTest("example_smiley", 256, 256, wasm_example_smiley)) passed++; else failed++;
    if (runTest("example_knot", 256, 256, wasm_example_knot)) passed++; else failed++;
    if (runTest("example_icon", 256, 256, wasm_example_icon)) passed++; else failed++;
    if (runTest("example_illusion", 256, 256, wasm_example_illusion)) passed++; else failed++;
    if (runTest("example_star", 256, 256, wasm_example_star)) passed++; else failed++;
    if (runTest("example_neon", 256, 256, wasm_example_neon)) passed++; else failed++;

    status.textContent += "\nResults: " + passed + " passed, " + failed + " failed, " + (passed + failed) + " total.";
    if (failed === 0)
        status.style.background = "#dfd";
    else
        status.style.background = "#fdd";
}
</script>

</body>
</html>