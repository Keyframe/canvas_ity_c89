# TOT Makefile â€” Brownfield AI Development Infrastructure
# Project: canvas-ity-c89
#
# This file is ADDITIVE. It never replaces or modifies your existing Makefile.
# Usage: make -f Makefile.tot <target>

SHELL := /bin/bash
PROJECT_NAME := canvas-ity-c89
TEST_CMD := make test
LINT_CMD := gcc -std=c89 -Wall -Wextra -Wpedantic -Werror -fsyntax-only src/canvas_ity.h
ANALYZE_CMD := make analyze
BUILD_CMD := make
FORMAT_CMD := echo 'no format tool available'
PUSH_ON_COMMIT := yes

# Detect active WI
ACTIVE_WI := $(shell ls .tot/active/*.state 2>/dev/null | head -1 | xargs -I{} basename {} .state 2>/dev/null)

# Detect GitHub remote
GITHUB_REMOTE := $(shell git remote get-url origin 2>/dev/null)

# Baseline-aware check: runs command, tolerates pre-existing failures.
# Usage: $(call baseline_check,command,label,baseline-prefix)
define baseline_check
$(1); CMD_EXIT=$$?; \
if [ $$CMD_EXIT -eq 0 ]; then \
	echo "$(2) passed."; \
elif [ -f .tot/baseline-$(3)-exitcode ] && [ "$$(cat .tot/baseline-$(3)-exitcode)" != "0" ]; then \
	echo "WARNING: $(2) failed (exit $$CMD_EXIT) but baseline also failed. Tolerating pre-existing failures."; \
else \
	echo "BLOCKED: $(2) failed (exit $$CMD_EXIT)."; exit 1; \
fi
endef

.PHONY: tot-status tot-start tot-commit tot-push tot-pr-create tot-finish tot-merge tot-add-wi tot-expand-scope tot-verify tot-baseline tot-format

tot-status:
	@echo "=== TOT Status ==="
	@echo "Project: $(PROJECT_NAME)"
	@echo ""
	@if [ -n "$(ACTIVE_WI)" ]; then \
		echo "Active: $(ACTIVE_WI)"; \
		echo "Branch: $$(git rev-parse --abbrev-ref HEAD)"; \
		cat .tot/active/$(ACTIVE_WI).state; \
		echo ""; \
		if [ -n "$(GITHUB_REMOTE)" ] && command -v gh >/dev/null 2>&1; then \
			BRANCH=$$(git rev-parse --abbrev-ref HEAD); \
			PR_URL=$$(gh pr view "$$BRANCH" --json url -q .url 2>/dev/null || echo "none"); \
			PR_DRAFT=$$(gh pr view "$$BRANCH" --json isDraft -q .isDraft 2>/dev/null || echo ""); \
			echo "PR: $$PR_URL"; \
			if [ "$$PR_DRAFT" = "true" ]; then echo "PR State: draft"; \
			elif [ -n "$$PR_DRAFT" ]; then echo "PR State: ready for review"; fi; \
		fi; \
	else \
		echo "No active work item."; \
		echo ""; \
	fi
	@echo "--- Backlog ---"
	@grep -E '^\- \[' .tot/backlog.md 2>/dev/null || echo "  (empty)"
	@echo ""
	@echo "--- Completed ---"
	@ls .tot/done/*.state 2>/dev/null | while read f; do basename "$$f" .state; done || echo "  (none)"

tot-start:
	@if [ -z "$(WI)" ]; then echo "Usage: make -f Makefile.tot tot-start WI=001 [TYPE=feat] [DESC=short-description]"; exit 1; fi
	@if [ -f ".tot/active/WI-$(WI).state" ]; then echo "WI-$(WI) is already active."; exit 1; fi
	@if ls .tot/active/*.state 1>/dev/null 2>&1; then \
		CURRENT=$$(ls .tot/active/*.state | head -1 | xargs basename 2>/dev/null | sed 's/\.state//'); \
		echo "BLOCKED: $$CURRENT is already active. Finish it first."; exit 1; \
	fi
	@if [ -f ".tot/done/WI-$(WI).state" ]; then echo "WI-$(WI) is already completed."; exit 1; fi
	@TYPE=$${TYPE:-feat}; \
	SCOPE=$$(grep -A1 "WI-$(WI)" .tot/backlog.md | grep 'Scope:' | sed 's/.*Scope:[[:space:]]*//' || echo ""); \
	if [ -z "$$SCOPE" ]; then \
		echo "WARNING: No scope found in backlog for WI-$(WI). Declare scope manually."; \
		read -p "Scope (comma-separated dirs, e.g., src/auth/,tests/auth/): " SCOPE; \
	fi; \
	echo "STATE=active" > .tot/active/WI-$(WI).state; \
	echo "STARTED=$$(date -Iseconds)" >> .tot/active/WI-$(WI).state; \
	echo "SCOPE: $$SCOPE" >> .tot/active/WI-$(WI).state; \
	echo "TYPE: $$TYPE" >> .tot/active/WI-$(WI).state; \
	BRANCH_NAME="tot/$$TYPE/WI-$(WI)"; \
	if [ -n "$(DESC)" ]; then BRANCH_NAME="$$BRANCH_NAME-$(DESC)"; fi; \
	git checkout -b "$$BRANCH_NAME" 2>/dev/null || git checkout "$$BRANCH_NAME"; \
	echo "=== WI-$(WI) activated on branch $$BRANCH_NAME ==="

tot-commit:
	@if [ -z "$(MSG)" ]; then echo "Usage: make -f Makefile.tot tot-commit MSG=\"WI-001 feat(api): add endpoint\""; exit 1; fi
	@echo "=== Running tests (baseline-aware) ==="
	@$(call baseline_check,$(TEST_CMD),Tests,test)
	@echo "=== Running lint (baseline-aware) ==="
	@$(call baseline_check,$(LINT_CMD),Lint,lint)
	@touch .tot/.commit-in-progress
	@git commit -m "$(MSG)"; RESULT=$$?; rm -f .tot/.commit-in-progress; \
	if [ $$RESULT -ne 0 ]; then exit $$RESULT; fi; \
	if [ "$(PUSH_ON_COMMIT)" = "yes" ] && [ -n "$(GITHUB_REMOTE)" ]; then \
		BRANCH=$$(git rev-parse --abbrev-ref HEAD); \
		git push -u origin "$$BRANCH" 2>&1 || echo "WARNING: Push failed. Run 'make -f Makefile.tot tot-push' manually."; \
		if command -v gh >/dev/null 2>&1; then \
			PR_EXISTS=$$(gh pr view "$$BRANCH" --json number 2>/dev/null | grep -c '"number"' || echo 0); \
			if [ "$$PR_EXISTS" = "0" ]; then \
				$(MAKE) -f Makefile.tot tot-pr-create; \
			fi; \
		fi; \
	fi

tot-push:
	@BRANCH=$$(git rev-parse --abbrev-ref HEAD); \
	git push -u origin "$$BRANCH"; \
	echo "Pushed $$BRANCH to origin."; \
	if command -v gh >/dev/null 2>&1 && [ -n "$(GITHUB_REMOTE)" ]; then \
		PR_EXISTS=$$(gh pr view "$$BRANCH" --json number 2>/dev/null | grep -c '"number"' || echo 0); \
		if [ "$$PR_EXISTS" = "0" ]; then \
			echo "No PR exists. Creating draft PR..."; \
			$(MAKE) -f Makefile.tot tot-pr-create; \
		else \
			echo "PR already exists."; \
		fi; \
	fi

tot-pr-create:
	@BRANCH=$$(git rev-parse --abbrev-ref HEAD); \
	WI_NUM=$$(echo "$$BRANCH" | grep -oP 'WI-\K[0-9]+' | head -1); \
	TYPE=$$(grep '^TYPE:' .tot/active/WI-$$WI_NUM.state 2>/dev/null | sed 's/^TYPE:[[:space:]]*//' || echo "feat"); \
	WI_LINE=$$(grep "WI-$$WI_NUM" .tot/backlog.md | head -1 | sed 's/^.*\] //' | sed 's/^([^)]*) //'); \
	SCOPE=$$(grep '^SCOPE:' .tot/active/WI-$$WI_NUM.state 2>/dev/null | sed 's/^SCOPE:[[:space:]]*//' || echo ""); \
	CRITERIA=$$(grep -A3 "WI-$$WI_NUM" .tot/backlog.md | grep 'Criteria:' | sed 's/.*Criteria:[[:space:]]*//' || echo ""); \
	PR_TITLE="$$TYPE: $$WI_LINE"; \
	gh pr create --draft --title "$$PR_TITLE" --body "$$(printf '## Summary\n\n%s\n\n## Scope\n\n`%s`\n\n## Acceptance Criteria\n\n%s\n\n## Work Item\n\nWI-%s\n' \
		"$$WI_LINE" "$$SCOPE" "$$CRITERIA" "$$WI_NUM")"; \
	echo "=== Draft PR created ==="

tot-finish:
	@if [ -z "$(WI)" ]; then echo "Usage: make -f Makefile.tot tot-finish WI=001"; exit 1; fi
	@if [ ! -f ".tot/active/WI-$(WI).state" ]; then echo "WI-$(WI) is not active."; exit 1; fi
	@echo "=== Running full test suite (baseline-aware) ==="
	@$(call baseline_check,$(TEST_CMD),Tests,test)
	@echo "=== Running full analysis (baseline-aware) ==="
	@$(call baseline_check,$(ANALYZE_CMD),Analysis,analyze)
	@echo "=== Running lint (baseline-aware) ==="
	@$(call baseline_check,$(LINT_CMD),Lint,lint)
	@echo "STATE=done" > .tot/done/WI-$(WI).state
	@echo "FINISHED=$$(date -Iseconds)" >> .tot/done/WI-$(WI).state
	@grep "^SCOPE:" .tot/active/WI-$(WI).state >> .tot/done/WI-$(WI).state 2>/dev/null || true
	@grep "^SCOPE_EXPANDED:" .tot/active/WI-$(WI).state >> .tot/done/WI-$(WI).state 2>/dev/null || true
	@grep "^TYPE:" .tot/active/WI-$(WI).state >> .tot/done/WI-$(WI).state 2>/dev/null || true
	@rm -f .tot/active/WI-$(WI).state
	@sed -i "s/- \[ \] WI-$(WI)/- [x] WI-$(WI)/" .tot/backlog.md 2>/dev/null || true
	@# Push final state and mark PR ready
	@if [ -n "$(GITHUB_REMOTE)" ]; then \
		BRANCH=$$(git rev-parse --abbrev-ref HEAD); \
		git push -u origin "$$BRANCH" 2>/dev/null || true; \
		if command -v gh >/dev/null 2>&1; then \
			PR_NUM=$$(gh pr view "$$BRANCH" --json number -q .number 2>/dev/null || echo ""); \
			if [ -n "$$PR_NUM" ]; then \
				gh pr ready "$$PR_NUM" 2>/dev/null && echo "PR #$$PR_NUM marked as ready for review." || true; \
			fi; \
		fi; \
	fi
	@echo "=== WI-$(WI) completed ==="

tot-merge:
	@if [ -z "$(WI)" ]; then echo "Usage: make -f Makefile.tot tot-merge WI=001"; exit 1; fi
	@if [ -f ".tot/active/WI-$(WI).state" ]; then echo "BLOCKED: WI-$(WI) not finished. Run tot-finish first."; exit 1; fi
	@if [ ! -f ".tot/done/WI-$(WI).state" ]; then echo "WI-$(WI) not found in done."; exit 1; fi
	@if [ -n "$(GITHUB_REMOTE)" ] && command -v gh >/dev/null 2>&1; then \
		echo "NOTE: This repo has a GitHub remote. Consider merging via the PR on GitHub instead."; \
	fi
	@CURRENT=$$(git rev-parse --abbrev-ref HEAD); \
	WI_BRANCH=$$(git branch --list 'tot/*/WI-$(WI)*' 'tot/WI-$(WI)*' | head -1 | tr -d ' '); \
	if [ -z "$$WI_BRANCH" ]; then echo "Could not find branch for WI-$(WI)."; exit 1; fi; \
	if [ "$$CURRENT" = "$$WI_BRANCH" ]; then \
		echo "BLOCKED: You are on the WI branch. Checkout target branch first (e.g., main)."; exit 1; \
	fi; \
	git merge "$$WI_BRANCH" --no-ff -m "Merge WI-$(WI): $$(grep "WI-$(WI)" .tot/backlog.md | head -1 | sed 's/^.*\] //' | sed 's/^([^)]*) //')"; \
	echo "=== WI-$(WI) merged ==="

tot-add-wi:
	@echo "Add work items to .tot/backlog.md using this format:"
	@echo ""
	@echo "  - [ ] WI-NNN [type] (priority) Description"
	@echo "    Scope: dir1/,dir2/"
	@echo "    Criteria: testable acceptance criteria"
	@echo ""
	@echo "Types: bug, feature, refactor, chore"
	@echo "Priorities: P0 (critical), P1 (high), P2 (medium), P3 (low)"
	@echo ""
	@echo "Or ask the AI agent to propose work items during a session."

tot-expand-scope:
	@if [ -z "$(WI)" ] || [ -z "$(DIR)" ]; then echo "Usage: make -f Makefile.tot tot-expand-scope WI=001 DIR=src/new_module REASON=\"justification\""; exit 1; fi
	@if [ ! -f ".tot/active/WI-$(WI).state" ]; then echo "WI-$(WI) is not active."; exit 1; fi
	@echo "SCOPE_EXPANDED: $(DIR)" >> .tot/active/WI-$(WI).state
	@echo "EXPAND_REASON: $(REASON)" >> .tot/active/WI-$(WI).state
	@echo "EXPAND_TIME: $$(date -Iseconds)" >> .tot/active/WI-$(WI).state
	@echo "=== Scope expanded for WI-$(WI): $(DIR) ==="
	@echo "Reason: $(REASON)"

tot-verify:
	@echo "=== Full verification (baseline-aware) ==="
	@echo "--- Tests ---"
	@$(call baseline_check,$(TEST_CMD),Tests,test)
	@echo "--- Analysis ---"
	@$(call baseline_check,$(ANALYZE_CMD),Analysis,analyze)
	@echo "--- Lint ---"
	@$(call baseline_check,$(LINT_CMD),Lint,lint)
	@echo "=== All checks passed ==="

tot-baseline:
	@echo "=== Capturing baseline ==="
	@$(TEST_CMD) > .tot/baseline-test.log 2>&1; echo $$? > .tot/baseline-test-exitcode; \
	if [ "$$(cat .tot/baseline-test-exitcode)" = "0" ]; then \
		echo "Tests: all passing."; \
	else \
		echo "Tests: failures recorded in baseline (exit $$(cat .tot/baseline-test-exitcode))."; \
	fi
	@$(LINT_CMD) > .tot/baseline-lint.log 2>&1; echo $$? > .tot/baseline-lint-exitcode; \
	if [ "$$(cat .tot/baseline-lint-exitcode)" = "0" ]; then \
		echo "Lint: clean."; \
	else \
		echo "Lint: findings recorded in baseline (exit $$(cat .tot/baseline-lint-exitcode))."; \
	fi
	@$(ANALYZE_CMD) > .tot/baseline-analyze.log 2>&1; echo $$? > .tot/baseline-analyze-exitcode; \
	if [ "$$(cat .tot/baseline-analyze-exitcode)" = "0" ]; then \
		echo "Analysis: clean."; \
	else \
		echo "Analysis: findings recorded in baseline (exit $$(cat .tot/baseline-analyze-exitcode))."; \
	fi
	@echo "Baseline captured in .tot/baseline-*.log and .tot/baseline-*-exitcode"

tot-format:
	@echo "=== Formatting ==="
	$(FORMAT_CMD)
	@echo "=== Format complete ==="
